% Template taken from https://github.com/independent-project-in-it-uu-2019/rapport-mall/blob/master/rapport-mall.tex

% MUST use a4paper option
% MAY use twoside, smaller font, and other class
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc} % Use UTF-8 encoding in input files
% NOTE: If you are writing in English, un-comment the following line:
\usepackage[swedish,english]{babel}
\usepackage{UppsalaExjobb} % Use the template for thesis reports

\usepackage{amssymb,amsmath,amsthm,amsfonts} % Useful font packages for maths and symbols
\usepackage{listings} % for nice code listings
\usepackage{placeins}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{hyperref}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
}
\urlstyle{same}

% styling of code
% \definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{%frame=tb,
  language=java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\fontsize{10}{11}\ttfamily},
% numbers=left,
% numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=false,
  tabsize=2,
  morekeywords={}
}

% Use one of these:
% - IEEEtranS gives numbered references like [42] sorted by author,
% - IEEEtranSA gives ``alpha''-style references like [Lam81] (also sorted by author)
% \bibliographystyle{IEEEtranSA}
\bibliographystyle{IEEEtranS}
\bstctlcite{IEEEexample:BSTcontrol}
%\bibliographystyle{plainurl}

% Designval: per default används styckesindrag, men ibland blir det snyggare/mer lättläst med tomrad mellan stycken. Det åstadkoms av de följande raderna.
% Tycker ni om styckesindrag mera, kommentera bort nästa två rader.
\parskip=0.8em
\parindent=0mm
% Designval: vill ni ha en box runt figurer istället för strecken som är default, av-kommentera raden nedan. Obs att både \floatstyle och \restylefloat behövs.
\floatstyle{boxed} \restylefloat{figure}
% \floatstyle{plain} \restylefloat{figure}

\begin{document}

% Set title, and subtitle if you have one
\title{To what extent is C\# being used as a functional programming language?}
% Use this if you have a subtitle
\subtitle{An evaluation of functional purity in C\#}
% Set author names, separated by "\\ " (don't forget the space)
% List authors alphabetically by last name (unless someone did significantly more/less)
\author{Melker Österberg}

% Set the date and year - use the right language!
\date{\begin{otherlanguage}{English}  %\foreignlanguage doesn't seem to affect \today?
\today
\end{otherlanguage}}

% Only need to set the year if it differs from the current year
%\year=2018
\handledare{Mikael Axelsson, Erik Löthman}
\reviewer{Konstantinos Sagonas}

% Programnamn på svenska och engelska
\progname{Civilingenjörsprogrammet i Informationsteknologi}{Master Programme in Computer and Information Engineering}

% Utgivare
\enhetsnamn{Institutionen för \\ Informationsteknologi}
%\enhetsnamn{Department of Information Technology}
\besoksadress{ITC, Polacksbacken\\ Lägerhyddsvägen 2}
\postadress{Box 337 \\ 751 05 Uppsala}
\hemsida{http:/www.it.uu.se}

% Set the name of the series, and the number in the series
\seriesname{Master Thesis}
%\seriesname{Independent Project in Information Engineering}
% \seriesname{Uppsatsmetodik}

% OBS: Gäller bara exjobb i årskurs 5
% Get a series number, e.g. from Studentservice Ångström
%\seriesnumber{}
% Use the appropriate ISSN for the series
%\issn{}
% Usually this is where it is printed
%\printer{}

% This creates the title page
\maketitle

% Change to frontmatter style (e.g. roman page numbers)
\frontmatter

\begin{abstract}
  TODO
\end{abstract}

\begin{sammanfattning}
  TODO
\end{sammanfattning}

% Innehållsförteckningen här.
\tableofcontents

% Här kan man också ha \listoffigures, \listoftables

\cleardoublepage

% Change to main matter style (arabic page numbers, reset page numbers)
\mainmatter

\section{Introduction} \label{sec:Introduction}
% https://dl-acm-org.ezproxy.its.uu.se/doi/pdf/10.1145/1455770.1455793?download=true has motivation for using pure functions in its abstract

Functional programming is on the rise and becoming more mainstream~\cite{intertech}. Object oriented (OO) programming has been the industry norm for quite some time now, and for a long time functional programming was considered by developers to only be applicable in academic domains. However it is now becoming popular in the IT industry as well. Many mainstream languages like Java, C\# and C++ have adopted first-class functions from the functional paradigm~\cite{intertech}. Moreover, functional programming can be used for building web applications and mobile apps~\cite{jonas-walter}.

Functional programs have many benefits over purely object oriented ones. Perhaps one of the most useful features of functional programming that the object oriented world of programming could adopt is \textit{functional purity}. Programs with pure functions are generally easier to reason about compared to object oriented ones because they have no \textit{side-effects}~\cite{alvin-alexander}. A side-effect is anything that a function does besides producing a return value~\cite{purity-in-javascript}. Pure functions are also easier to test since all we need to look at are functions' inputs and outputs, which also, for instance, facilitates property-based testing~\cite{alvin-alexander}. Moreover, research has shown that pure programs are easier to debug and maintain~\cite{purity-in-javascript}. % page 1
For this reason it useful in software engineering to evaluate the level of functional purity in programs~\cite{purity-in-javascript}.

C\# is among the top five most popular programming languages~\cite{tiobe}. To its core, it is an object-oriented programming language. However, it has features that allow for functional programming~\cite{hamid-mosalla}. But to what extent is C\# being used as a functional programming language by developers? This paper will attempt to answer this by evaluting to what degree functional purity is used in C\# programs today.

% Yannis Smaragdakis and Brian McNamara showed that there are ways of converting the common OO design patterns Command, Observer, Adaptor, Visitor and Virtual Proxy in C++ to functional programs using FC++ -- a library that adds many functional features to C++~\cite{yannis-smaragdakis}. Would this kind of transformation be useful for programs written in C\#? If C\# is not currently being used primarily as a functional programming language, this tool could be useful to programmers that want to refactor an existing OO program to a functional one.

\section{Background} \label{sec:Background} % (several sections depending on work)

\subsection{Definitions} \label{sub:Definitions}
Following are definitions of functional and objected oriented programming respectively.
% Are there multiple definitions? Motivate choice of definitions?

\textbf{Functional programming}

\begin{enumerate}
  \item All functions are \emph{pure}, meaning that they do not have any side-effects, and their output depends only on the input~\cite{john-m-chambers}. The latter is what Finifter et al. call \textit{determinism}, as mentioned in \autoref{sub:Verifiable-Functional-Purity-in-Java}~\cite{purity-in-java}.
    % We will go in more to this in \autoref{sub:Definition of functional purity}
\item Functions are first-class and can be higher-order, meaning that functions can be passed to functions as parameters, and can be returned by functions~\cite{jonas-walter}. % page 3
\item Variables are immutable, meaning that their value does not change after being initiated~\cite{jonas-walter}. % page 3
\end{enumerate}

\textbf{Object oriented programming} % Perhaps also mention imperative programming?

\begin{enumerate}
\item Computations are done via \emph{methods} belonging to \emph{objects}, whose structure suits the goal of whatever computation we're doing~\cite{john-m-chambers}.
\item Objects are based on \emph{classes}, and objects belonging to a class have a shared set of properties~\cite{john-m-chambers}.
\item Classes can \emph{inherit} from other superclasses, such that a class is also an instance of its superclass~\cite{john-m-chambers}.
\end{enumerate}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}} % -------- Line break --------

\textbf{*Add a description of the following*}
\begin{itemize}
  \item Side-effects and referential transparency, which implies purity~\cite{purity-in-javascript}
  \item .NET Core/C\#
  \item Compilers
  \item Abstract syntax trees (ASTs)
  \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-syntax}{.NET ASTs}~\cite{albahari2003nutshell}
\end{itemize}

Microsoft has an article on refactoring none-pure C\# code to pure functions \cite{microsoft-refactoring}.

\textbf{*Things to consider*}

\begin{itemize}
  \item Abstract syntax trees
  \item Input/output
  \item Recursion
  \item Monads
  \item Call-by-value vs. call-by-reference: % \textit{"For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed. This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object). Call-by-reference is not necessarily required for a function to modify a parameter."} - \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions}{link}.
  % \item Functions can be locally pure and/or globally pure https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions
  \item Control flow analysis
  \item Could talk about Haskell in which all functions are pure and all values are immutable
  \item Sometimes we call compiled methods, i.e. methods that we don’t have the code for, e.g. the .NET framework base class library (BCL)
  \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/}{Delegates} and \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions}{anomynous functions}.
  \item Implicit and explicit variable declarations (C\# handles both)
  \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/identifier-names}{Identifiers} are the names of types, members variables or namespaces used in source code. They reference \href{https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-semantics#symbols}{symbols}, representing a declared namespace, type, method, field, variable, etc. The compiler's process of associating identifiers with symbols is called \textit{binding}~\cite{microsoft-semantic-analysis}. % TODO explain symbols and identifiers
  \item Closures and how objects can be considered closures (if fields are \texttt{readonly}?), and whether or not they should be considered pure.
\end{itemize}

% \subsection{The C\# Language} \label{sub:The C\# Language}
% TODO: short description of C\#

\subsection{Definition of functional purity} \label{sub:Definition of functional purity}
% Maybe move this before subsection to lead up to this?
As mentioned in \autoref{sec:Background}, the definition of functional programming consists of three parts. \textit{Purity}, functions being \textit{first-class} and \textit{higher-order}, and variables being \textit{immutable}. To delimit the scope of this thesis it will only focus on purity, mainly because it is the one which seems the most useful for object oriented programming, and as it is the one that is the most emphasized as a benefit of using a more functional style in object oriented programming~\cite{alvin-alexander}. % page 19

As seen in \autoref{sec:Related work} a lot of related work defines purity only as being synonymous with side-effect free. This definition therefore doesn't require functions' output to depend purely on their input -- what Finifter et al. call \textit{determinism}, as mentioned in \autoref{sub:Verifiable-Functional-Purity-in-Java} -- but allows them to read from variables defined outside of their scope. This definition is less functional. The definition of purity used in this thesis will therefore require pure functions to not only be side-effect free but also to be deterministic. This is the definition of purity that is used by Finifter et al.~\cite{purity-in-java}, Pitidis et al.~\cite{pitidis2010purity} and Alexander~\cite{alvin-alexander}, % page 19
the first two who's work is mentioned in \autoref{sub:Purity-in-Erlang} and \autoref{sub:Verifiable-Functional-Purity-in-Java}, respectively. Moreover, requiring pure functions to be both side-effect free \textit{and} deterministic does in a way also simplify the analysis because it means that any symbol used in a function \textit{F} but defined outside \textit{F} would make \textit{F} impure. If we allowed pure functions to be non-deterministic, that would mean that we would have to check each symbol used in \textit{F} to see if it is being written to or if it is only being read before concluding if \textit{F} is pure.

Thus, a function is pure if it is side-effect free and deterministic.

\subsection{What makes a C\# method pure?} \label{sub:What makes a Cs program functional?}
\autoref{fig:impure-example} and \autoref{fig:pure-example} illustrate two very simple examples of pure and impure code, respectively. In \autoref{fig:impure-example} the function \texttt{addOne()} is impure because it is writing to the variable \texttt{number} which was defined outside \texttt{addOne()}'s scope, which is a side-effect. \autoref{fig:pure-example} illustrates how \texttt{addOne()} can be rewritten to a pure function while preserving the program's semantics.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int number = 42;
    addOne();
    Console.WriteLine(number);

    void addOne()
    {
      number += 1; // this is a side-effect
    }
  \end{lstlisting}
  \caption{A simple example of \textit{impure} code due to a side-effect.}
  \label{fig:impure-example}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int number = 42;
    number = addOne(number);
    Console.WriteLine(number);

    int addOne(int num)
    {
      return num + 1;
    }
  \end{lstlisting}
  \caption{This is how \texttt{addOne()} from the example in \autoref{fig:impure-example} can be rewritten and used as a \textit{pure} function.}
  \label{fig:pure-example}
\end{figure}

Following are more technical requirements for C\# programs to be pure that are used as a basis for the implementation of the analysis tool. % maybe move to implementation?

% 1. Output depends only on input
% 2. No side-effects

\begin{itemize}
  \item Functions that modify any value outside their scope, e.g. a class variable or global variable, are impure. Modifying a value could be done by assigning a new value to it, or changing a part of it like modifying an element of a list or an object property.
  % Does this apply to all non-returning statements with no assignment, i.e. no '\texttt{=}' sign? Not if the data being modified through a method is inside the scope of the function.
  \item Functions that read any value outside the function's scope are impure. Reading a value could be done in many ways, including using it as argument in a function, as a condition in an \texttt{if}-statement, assigning it to a variable, etc. Basically any non-local variable appearing in a function would imply an impure read (except for if it is assigned to, which is mentioned above).
  % \item Functions that call other functions without reading the called function's return value are not pure?
  \item Functions that return \texttt{void} are assumed to be impure (because in order for them to have an effect on the program, they must have a side-effect).
  \item
  % By looking at the return statement of a function \textit{F} we could trace the variables and functions involved backwards in order to figure out \textit{F}'s purity. If all variables used in \textit{F}'s return statement are either input parameters or instantiated inside \textit{F}, \textit{F} is considered pure.
  This means that any variable read from or assigned to in a function \textit{F} must have been instantiated inside \textit{F} in order for \textit{F} to be pure.
  If any of \textit{F}'s parameters is an object, that object cannot be modified inside \textit{F} (at least not for the highest level of purity).
  \item Functions that call impure functions are themselves also impure.
  \item Functions that involve input/output (I/O) are impure.
\end{itemize}

Function parameters preceded with the \texttt{in} keyword are passed by reference and read-only inside the function~\cite{microsoft-in-modifier}. % This means that \texttt{in} parameters do not need to be checked (TODO: does this apply to data structures like lists?)
This means that input parameters marked with \texttt{in} cannot be re-assigned inside the function, which may suggest functional purity. Consider the example in \autoref{fig:in-example1}, where the parameter \texttt{number} is preceded by the \texttt{in} keyword. Because of this, modifying it inside the function will raise an error.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int globalValue = 42;
    addOne(globalValue);
    Console.WriteLine(globalValue); // value is still 42

    void addOne(in int number) // note the `in` keyword
    {
      number += 1; // illegal assignement will raise error CS8332
    }
  \end{lstlisting}
  \caption{Assignment to the parameter \texttt{number} which is preceded with \texttt{in} raises an error~\cite{microsoft-in-modifier}.}
  \label{fig:in-example1}
\end{figure}

However, \texttt{in} is note a purity guarantee. Consider the example in \autoref{fig:in-example2}. The \texttt{in} keyword before the argument \texttt{list} ensures that \texttt{list} is readonly. This prevents \texttt{list} from being re-assigned after instantiation, but it doesn't prevent the data structure which \texttt{list} refers to from being modified~\cite{buchanan-static-lists}. In C\# there are two kinds of types: \textit{value types} and \textit{reference types}~\cite{microsoft-types}. Value types directly contain their data, while reference types -- also known as objects -- are simply pointers that refer to the location of their data. The \texttt{in} keyword therefore only implies purity if applied to a variable of a value type. For the function to be pure all its parameters have to be value types and preceded with the \texttt{in} keyword. Even though strings are of the reference type they are immutable, meaning that they cannot be modified after being created~\cite{microsoft-strings}. Therefore the same thing that in this case applies to value types also applies to strings.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    List<int> globalValue = new List<int>{42};
    addOne(globalValue);
    globalValue.ForEach(Console.WriteLine); // list is now {42, 1}

    void addOne(in List<int> list) // note the `in` keyword
    {
      list.Add(1); // this will _not_ raise an error even though
                       // Add(1) modifies the list
    }
  \end{lstlisting}
  \caption{The expression \texttt{list.Add(1)} which writes a value to \texttt{list} is allowed, even though \texttt{list} is read-only due to its preceding \texttt{in} keyword.}
  \label{fig:in-example2}
\end{figure}

TODO

\subsection{The .NET Abstract Syntax Tree and the CodeAnalysis library} \label{The .NET Abstract Syntax Tree and the CodeAnalysis library}

In this thesis the term \textit{method} and \textit{function} will be used interchangeably.

% Abstract syntax trees in general
Abstract syntax trees (AST) are the primary data structure used when analysing code~\cite{microsoft-work-with-syntax}. It encapsulates every piece of information held in the source code~\cite{microsoft-work-with-syntax}. A syntax tree generated by a parser can be be re-built into the exact same text that was originally parsed~\cite{microsoft-work-with-syntax}. TODO

The abstract syntax tree (AST) generated by the texttt{Microsoft.CodeAnalysis} library represents the lexical and syntactic structure of a .NET program~\cite{microsoft-work-with-syntax}. The tree consists primarily of \textit{syntax nodes} which represent syntactic constructs including declarations, statements, clauses and expressions~\cite{microsoft-work-with-syntax}. Each node is derived from the \texttt{Syntax}-\texttt{Node} class~\cite{microsoft-work-with-syntax}. Every node is non-terminal, meaning that they always have children - either other nodes or \textit{tokens}~\cite{microsoft-work-with-syntax}. Tokens are the smallest syntactic pieces of the program, consisting of keywords identifiers, literals and punctuation~\cite{microsoft-work-with-syntax}.

% An \textit{expression} consists of zero or more operators with one or more operands, which can be evaluated to a single value, method, object or namespace.
% https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expressions

\subsubsection{Microsoft Syntax Analysis API CodeAnalysis} \label{ssub:Microsoft Syntax Analysis API}
\texttt{Microsoft.CodeAnalysis} is a Syntax API developed by Microsoft which allows programmers to convert a C\# program to an abstract syntax tree and traverse it~\cite{microsoft-syntax-API}. TODO

\textbf{AST nodes}

\begin{itemize}
  \item The \texttt{ClassDeclarationSyntax} node represents the declaration of a class.
  \item The \texttt{MethodDeclarationSyntax} node represents the declaration of a meth-od. Each \texttt{MethodDeclarationSyntax} node has a \texttt{ParameterListSyn}- \texttt{tax} - a list of \texttt{ParameterSyntax} nodes represents, each representing a me-thod parameter.
  \item The \texttt{LocalFunctionStatementSyntax} node represents a function decla-red inside a method. Just like the \texttt{MethodDeclarationSyntax} it has a \texttt{Param}-\texttt{eterListSyntax} representing the local function's parameters.
  \item The \texttt{ReturnStatementSyntax} node represents the \texttt{return} token.
  \item The \texttt{VariableDeclarationSyntax} node represents declarations of new variables.
  \item The \texttt{LocalDeclarationStatementSyntax} node represents declarations of new local variables. This node contains a \texttt{VariableDeclarationSyntax} node.
  \item The \texttt{AssignmentExpressionSyntax} node represents assignments to already instantiated variables.
  \item The \texttt{IdentifierNameSyntax} node represents symbols used in the code, including variable names and method names.
\end{itemize}

\subsection{Analysis}
\begin{itemize}
  \item Traverse the Abstract Syntax Tree (AST) and build the \textit{dependency set} - set of calls to other functions~\cite{pitidis2010purity}.
  \item Build a lookup table with all evaluated functions, their purity and their dependency set~\cite{pitidis2010purity}.
\end{itemize}

\subsection{Code base} \label{sub:Code base}
\textbf{Mostly pure code}
\begin{itemize}
  \item \href{https://github.com/dotnet/roslyn/blob/master/src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/Utilities/CompilerUtilities/ImmutableHashMap.cs}{\texttt{ImmutableHashMap.cs}} - has many methods marked with \texttt{[pure]}
  \item \href{https://github.com/nodatime/nodatime/blob/master/src/NodaTime}{NodaTime} has many pure methods. NodaTime's \href{https://github.com/nodatime/nodatime/blob/master/src/NodaTime/AnnualDate.cs}{\texttt{AnnualDate.cs}} for instance has many pure methods not marked with \texttt{[pure]}
\end{itemize}

\textbf{Mostly impure code}
\begin{itemize}
  \item \href{https://github.com/SixLabors/ImageSharp/blob/master/src/ImageSharp}{ImageSharp}
  \item \href{https://github.com/geaz/sharpDox}{sharpDox}
\end{itemize}

\section{Implementation of the analysis tool} \label{sec:Implementation of the analysis tool}
% \item For performance reasons, first check general stuff and then do more specific checks.

% Because of the poor documentation of the \texttt{CodeAnalysis} library, a lot of time was spent on playing around with it and figuring out how it is intended to be used.

Because there was a clear goal for the software and it's requirements, test driven development was used.

Because .NET has many libraries with functions of unknown purity, the purity level "unknown" has to be added.

The code analysis tool is built in .NET core and C\#. It can be compiled, run and tested from the command line using the command \href{https://docs.microsoft.com/en-us/dotnet/core/tools/}{\texttt{dotnet}}, followed by \texttt{run}, \texttt{build} or \texttt{test}, respectively.

To find the declaration/definition of symbols (in the form of \texttt{IdentifierNameSyn\allowbreak tax}) the method \texttt{SemanticModel.GetSym\allowbreak bolInfo()} is used, which uses the semantic model of the program.

TODO

\section{Results} \label{sec:Results}
TODO

\section{Related work} \label{sec:Related work} % (If not part of introduction)

\subsection{Purity in Erlang} \label{sub:Purity-in-Erlang}
In their paper \textit{Purity in Erlang} Mihalis Pitidis and Konstantinos Sagonas develop a tool that automatically and statically analyses the purity of Erlang functions~\cite{pitidis2010purity}. It classifies functions into being functionally pure, or one of three levels of functional impurity~\cite{pitidis2010purity}.
The three levels of functional impurity they defined are: containing side-effects; containing no side-effects but being dependent on the environment; and containing no side-effects, having no dependencies on the environment but raising exceptions~\cite{pitidis2010purity}.

Their definition of purity uses \textit{referential transparency}, as it implies purity~\cite{pitidis2010purity}. Referential transparency means that an expression always produces the same value when transparency~\cite{pitidis2010purity}. This means that a referentially transparent function could always be replaced with it's output without altering the program's behaviour in any way~\cite{pitidis2010purity}.

They store all analysis information in a \textit{lookup table} where the keys are the function identifiers \textit{f} and the values are the purity level \textit{$p_f$} of each \textit{f} as well as \textit{f}'s \textit{dependency set} $D_f$~\cite{pitidis2010purity}. The dependency set is the set of functions being called by \textit{f} and is constructed by parsing the program's Abstract Syntax Tree~\cite{pitidis2010purity}.

Their analysis starts with Erlang's so called built in-functions (BIFs), which are functions native to the Erlang's virtual machine and are written in C~\cite{pitidis2010purity}. Impure actions in Erlang can only be done through BIFs, including performing I/O actions or writing to global variables~\cite{kostis-email}. Because BIFs are written in C they cannot be analysed by their analysis tool, and their purity is assumed to be already known in beforehand by the analysis tool~\cite{pitidis2010purity}. The analysis propagates the impurity of BIFs to each function which directly or indirectly depends on them.

In short terms, their analysis algorithm works like this: Initialize the purity of all functions in the lookup table to be analyzed to "pure"~\cite{pitidis2010purity}. Define the \textit{working set} to always equal the set of functions whose purity level is fully determined, i.e. the functions with empty dependency sets~\cite{pitidis2010purity}. For each function \textit{f} in the working set, propagate its purity level to functions depending on it and "contaminate" them with \textit{f}'s purity level~\cite{pitidis2010purity}. Then remove \textit{f} from the  dependency set of each function depending on it~\cite{pitidis2010purity}. If \textit{f} has the highest impurity level, remove the entire dependency set of each function depending on \textit{f}~\cite{pitidis2010purity}. If the working set gets empty, find a set of functions that are dependent on each other and no other functions, and set their purity level to the purity of the impurest function~\cite{pitidis2010purity}. Simplify their dependency sets by removing their dependency on each other from their dependency set~\cite{pitidis2010purity}. Repeat this process until there are no more changes to the lookup table~\cite{pitidis2010purity}.

TODO

% By parsing the Abstract Syntax Tree of the code they construct a \textit{dependency set} for each function \textit{f}, i.e. the set of functions being called by \textit{f} ... TODO (page 5 in \cite{pitidis2010purity}).

\subsection{Detecting function purity in JavaScript}
% This was a little too difficult to understand, maybe remove from related work?
Nicolay et al. developed a method of detecting function purity in JavaScript using something called \textit{pushdown analysis}~\cite{purity-in-javascript}. Their definition of functional purity, however, includes only side-effects and does not require functions' output to depend purely on their input~\cite{purity-in-javascript}.

% Because everything except for

\subsection{Purity and Side Effect Analysis for Java Programs} \label{sub:Purity and Side Effect Analysis for Java Programs}
Similarly, S\u{a}lcianu and Rinard presented a method for analysing purity in Java programs, but their definition of purity also only includes side-effects and does not look at the input or output~\cite{salcianu}. Their pointer analysis is based on tracking object creation and updates, as well as updates to local variables, and defines methods that mutate memory locations that existed before a method call as impure~\cite{salcianu}. Moreover, their analysis can recognize purity-related properties for impure methods, including \textit{read-only} and \textit{safe} parameters~\cite{salcianu}.

The analysis method presented looks at each program point in each method \textit{m}, and computes a points-to graph modelling the parts of the heap that method \textit{m} points to, represented by nodes in the graph~\cite{salcianu}. There are three kinds of nodes. \textit{Inside nodes} which model objects created by \textit{m}, \textit{parameter nodes} which model objects passed to \textit{m} as arguments, and \textit{load nodes} modelling objects read from outside \textit{m}. Edges in the points-to graph model heap references. There are two types of edges: \textit{inside edges} which model heap references created by \textit{m}, and \textit{outside edges} modelling heap references read by \textit{m} from outside of it (this includes \textit{m}'s parameters).

For each method \textit{m} the analysis computes a set $W_m$ containing the mutated fields that are externally visible.

TODO

\subsection{Writing Pure Code in C\#} \label{sub:Writing Pure Code in Cs}
In his article \textit{Writing Pure Code in C\#} Massad defines three levels of pure methods~\cite{yacoub-massad-pure-code}:
\begin{enumerate}
  \item Pure methods, i.e. methods that do not read or write to instance state variables, or call impure methods.
  \item Methods that are pure, and that \textit{read} the state of their containing object, or the state of objects that are passed as parameters or created in the current method.
  \item Methods that are pure, and that \textit{read} or \textit{write} to the state of their containing objects, or to the state of objects created in the current method.
\end{enumerate}

\subsection{.NET Code Contracts} \label{sub:Code contracts} % kanske ta bort eller flytta till Backgrounds?
.NET code contracts are used to define pre- and postconditions, as well invariants for pieces of code -- some which can be checked statically and some at runtime~\cite{microsoft-code-contracts}. One available code contract is the \texttt{[pure]} attribute, which requires the method to be pure~\cite{microsoft-code-contracts}. Microsoft defines pure methods as methods that don't modify an pre-existing state, i.e. methods can only modify objects that were created \textit{after} the method was called. The following code elements are assumed by the code contract tools to be pure~\cite{microsoft-code-contracts}:

\begin{itemize}
  \item Methods or types marked with \texttt{[pure]} (for types marked with \texttt{[pure]} this should apply to to all the type's methods).
  \item Property get accessors.
  \item Operators.
  \item Any method with a fully qualified name starting with \texttt{System.Diagnost\-ics.Contracts.Contract}, \texttt{System.String}, \texttt{System\-.IO.Path}, or \texttt{System.Type}.
  \item Any called delegate with the \texttt{[pure]} attribute. Delegates are basically function pointers.
\end{itemize}

\subsection{Evolution of Degree of Purity in Programming Languages} \label{sub:Evolution of Degree of Purity in Programming Languages}
Rajasekhara Babu et al.~\cite{rajasekharababu2012evolution}.

\subsection{Verifiable Functional Purity in Java} \label{sub:Verifiable-Functional-Purity-in-Java}
In their definition of functional purity Finifter et al. require pure functions to be both side-effect free and \textit{deterministic}~\cite{purity-in-java}. A function is deterministic if any two evaluations of it have the same result~\cite{purity-in-java}. This means that a deterministic function is one that relies purely on its arguments~\cite{purity-in-java}. A function is side-effect free if it only modifies objects that were created during its execution~\cite{purity-in-java}.

They make the point that if all of method's parameters are immutable, including the implicit \texttt{this}, then the method is pure~\cite{purity-in-java}. % page 166
If its class is immutable it means that a method's global scope has a constant state, and so the only varying state is the one observable through its arguments~\cite{purity-in-java}.

Their verifier has a white list of fields and methods from Java libraries that do not expose the ability to observe a global mutable state, or provide access to nondeterminism, and it will reject any reference to a field or method that is not on the list~\cite{purity-in-java}.

\section{Future Work and Conclusion} \label{sec:Conclusion and future Work}
\subsection{Future work} \label{sub:Future work}

\begin{itemize}
  \item Tool can point out exact position of impurity and suggest improvements to increase the purity.
\end{itemize}

\subsection{Conclusion} \label{sub:Conclusion}
\textit{Functional purity} is perhaps the most useful concept from functional programming that object oriented programmers can learn from. The definition of a pure program used in this paper is one that is side-effect free and determinstic.

\bibliography{references}

%\appendix % markerar att resten är appendix

\end{document}
