% Template taken from https://github.com/independent-project-in-it-uu-2019/rapport-mall/blob/master/rapport-mall.tex

% MUST use a4paper option
% MAY use twoside, smaller font, and other class
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc} % Use UTF-8 encoding in input files
% NOTE: If you are writing in English, un-comment the following line:
\usepackage[swedish,english]{babel}
\usepackage{UppsalaExjobb} % Use the template for thesis reports

\usepackage{amssymb,amsmath,amsthm,amsfonts} % Useful font packages for maths and symbols
\usepackage{listings} % for nice code listings
\usepackage{placeins}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{hyperref}
\usepackage{colortbl}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
}
\urlstyle{same}

% styling of code
% \definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{lightgray}{rgb}{0.9,0.9,0.9}

\lstset{%frame=tb,
  language=java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  basicstyle={\fontsize{10}{11}\ttfamily},
% numbers=left,
% numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=false,
  tabsize=2,
  morekeywords={using}
}

% Use one of these:
% - IEEEtranS gives numbered references like [42] sorted by author,
% - IEEEtranSA gives ``alpha''-style references like [Lam81] (also sorted by author)
% \bibliographystyle{IEEEtranSA}
\bibliographystyle{IEEEtranS}
\bstctlcite{IEEEexample:BSTcontrol}
%\bibliographystyle{plainurl}

% Designval: per default används styckesindrag, men ibland blir det snyggare/mer lättläst med tomrad mellan stycken. Det åstadkoms av de följande raderna.
% Tycker ni om styckesindrag mera, kommentera bort nästa två rader.
\parskip=0.8em
\parindent=0mm
% Designval: vill ni ha en box runt figurer istället för strecken som är default, av-kommentera raden nedan. Obs att både \floatstyle och \restylefloat behövs.
\floatstyle{boxed} \restylefloat{figure}
% \floatstyle{plain} \restylefloat{figure}

\newtheorem{definition}{Definition} % Adds the \begin{definition}...
\newcommand*{\definitionautorefname}{definition} % Allows autoref to definition

\newcommand{\Autoref}[1]{%
  \begingroup%
  \def\chapterautorefname{Chapter}%
  \def\sectionautorefname{Section}%
  \def\subsectionautorefname{Subsection}%
  \def\itemautorefname{Item}%
  \autoref{#1}%
  \endgroup%
}

\begin{document}
\title{Measuring functional purity in C\#}
\subtitle{Developing and implementing a technique for measuring functional purity in C\#, and evaluating it using the \texttt{[Pure]} attribute}
\author{Melker Österberg}

% Set the date and year - use the right language!
\date{
  \begin{otherlanguage}{English}  %\foreignlanguage doesn't seem to affect \today?
    \today
  \end{otherlanguage}
}

% Only need to set the year if it differs from the current year
%\year=2018
\handledare{Mikael Axelsson, Erik Löthman}
\reviewer{Konstantinos Sagonas}

% Programnamn på svenska och engelska
\progname{Civilingenjörsprogrammet i Informationsteknologi}{Master Programme in Computer and Information Engineering}

% Utgivare
\enhetsnamn{Institutionen för \\ Informationsteknologi}
%\enhetsnamn{Department of Information Technology}
\besoksadress{ITC, Polacksbacken\\ Lägerhyddsvägen 2}
\postadress{Box 337 \\ 751 05 Uppsala}
\hemsida{http:/www.it.uu.se}

% Set the name of the series, and the number in the series
\seriesname{Master Thesis}
%\seriesname{Independent Project in Information Engineering}
% \seriesname{Uppsatsmetodik}

% OBS: Gäller bara exjobb i årskurs 5
% Get a series number, e.g. from Studentservice Ångström
%\seriesnumber{}
% Use the appropriate ISSN for the series
%\issn{}
% Usually this is where it is printed
%\printer{}

% This creates the title page
\maketitle

% Change to frontmatter style (e.g. roman page numbers)
\frontmatter

\begin{abstract}
  Functional purity is a fundamental part of the functional programming paradigm. A function is functionally pure if it is side-effect free and deterministic. Pure functions provide many benefits compared to impure ones, including guaranteed thread-safety as well as easier testing, debugging and maintenance. But how can functional purity be measured? This thesis develops a method for statically measuring the level of functional purity in any given C\# program. It also investigates problems with determining purity in object-oriented languages, with a focus on C\#. Moreover, a prototype of the method is implemented in order to evaluate the method using a benchmark consisting of 11 open source repositories that use C\#'s \texttt{[Pure]} attribute. The \texttt{[Pure]} attribute can be placed in front of a method declaration to indicate that it is side-effect free. Due to a number of limitations to the implementation as well as to \texttt{[Pure]}'s definition of functional purity, which excludes determinism, the results of the evaluation appear relatively poor. After normalizing the implementation's classification distribution for each repository its classification of pure functions has a precision of 65\% and recall 17\%, and its classification of impure functions has 54\% precision and 69\% recall. Nevertheless, the prototype still shows the potential of the full analysis method. A complete implementation of the analysis method could potentially yield a fully working system for measuring any C\# program's level of functional purity.
\end{abstract}

% Innehållsförteckningen här.
\tableofcontents

% Här kan man också ha \listoffigures, \listoftables

\cleardoublepage

% Change to main matter style (arabic page numbers, reset page numbers)
\mainmatter

\section{Introduction} \label{sec:Introduction}

The object-oriented programming paradigm has been the industry norm for quite some time~\cite{tiobe}. However, functional programming is on the rise and becoming more popular~\cite{intertech}. Many mainstream languages like Java, C\# and C++ have adopted first-class functions from the functional paradigm~\cite{intertech}. While perhaps some associate functional programming with the more theoretical and mathematical fields, functional programming can be used for more practical applications like building modern web applications and mobile apps~\cite{jonas-walter}.

Functional programs have many benefits. Perhaps one of the most useful features of functional programming that the object-oriented world of programming could adopt is \textit{functional purity}. Programs with pure functions are generally easier to reason about than impure ones because they have no \textit{side effects}~\cite{alvin-alexander}. A side effect is anything that a function does besides producing a return value and that is visible outside the function~\cite{purity-in-java}. Pure functions are always thread-safe, meaning that they are very suitable for parallel programming~\cite{purity-in-java}. Pure functions are also easier to test compared to impure ones since all we need to look at are functions' inputs and outputs, which also, for instance, facilitates property-based testing~\cite{alvin-alexander}. Moreover, research has shown that pure programs are easier to debug and maintain~\cite{purity-in-javascript}. % page 1
For this reason it is useful in software engineering to be able to measure the level of functional purity in programs~\cite{purity-in-javascript}.

C\# is among the top five most popular programming languages~\cite{tiobe}. To its core, it is an object-oriented programming language. However, it has features that allow for functional programming~\cite{hamid-mosalla}. But to what extent is C\# being used as a functional programming language?
In order to answer this and questions like it, we need a method for measuring a C\# program's functional purity level. We also need a way of evaluating that method in order to assess its level of accuracy. The purpose of this thesis is thus to develop an analysis method for measuring the functional purity level of any C\# program.

The following are the contributions of this thesis:

\begin{itemize}
  \item A static analysis method for measuring the level of functional purity in a C\# program.
  % \item Prototype CsPurity?
  \item Techniques for how to deal with a number of problems that arise when measuring purity in an object-oriented programming language.
\end{itemize}

 The next section presents similar work done in other programming languages. \Autoref{sec:definitions} contains definitions for functional purity, functional programming, and object-oriented programming. \Autoref{sec:the-csharp-language} describes C\# and .NET, as well as a description of what makes C\# method pure. \Autoref{sec:problems-with-purity-in-oo} presents a number of dilemmas when it comes to measuring purity in object-oriented languages, and how they were addressed. \Autoref{sec:the-analysis-method} describes the analysis method used, and applies it to a simple C\# program. \Autoref{sec:implementation-of-cspurity} describes the implemented prototype of the analysis method -- CsPurity. \Autoref{sec:results-and-discussion} presents the results after running CsPurity on the example code in \autoref{sec:the-analysis-method}, as well as on 11 open source repositories that use the \texttt{[Pure]} attribute, which was used to evaluate CsPuritiy's precision and recall. The results are then discussed at the end of \autoref{sec:results-and-discussion}, and the thesis is concluded in \autoref{sec:conclusion}.

\section{Related work} \label{sec:related-work} % (If not part of introduction)

The problem of detecting functional purity has been studied in other programming languages. Even though each language has its unique features there is a lot to be learned from how other people have approached the subject. This section describes related work done for purity analysis in Erlang as well as Java. Since Java is object-oriented, it is relatively similar to C\#, and so four out of the five related works cover purity analysis in Java.

Not all literature defines functional purity the same, as will become clear in this section. Each subsection includes that work's definition. The definition for functional purity used in this thesis, as well its motivation, is in \autoref{sec:definitions}.

\subsection{Purity in Erlang} \label{sub:Purity-in-Erlang}

In their paper \textit{Purity in Erlang} Mihalis Pitidis and Konstantinos Sagonas develop a tool that automatically and statically analyzes the purity of Erlang functions~\cite{pitidis2010purity}. While Erlang as a language is quite different compared to C\#, the method described by Pitidis and Sagonas is relatively simple, which makes it relatively easy to adapt to work on C\# code. % TODO

The method described by Pitidis and Sagonas classifies functions into being functionally pure, or one of three levels of functional impurity~\cite{pitidis2010purity}. The three levels of functional impurity they defined are: containing side effects; containing no side effects but being dependent on the environment; and containing no side effects, having no dependencies on the environment but raising exceptions~\cite{pitidis2010purity}.

Their definition of purity uses \textit{referential transparency}, as it implies purity~\cite{pitidis2010purity}. Referential transparency means that an expression always produces the same value when evaluated~\cite{pitidis2010purity}. This means that a referentially transparent function could always be replaced with its output without altering the program's behaviour in any way~\cite{pitidis2010purity}.

They store all analysis information in a \textit{lookup table} where the keys are the function identifiers \textit{f} and the values are the purity level \textit{$p_f$} of each \textit{f} as well as \textit{f}'s \textit{dependency set} $D_f$~\cite{pitidis2010purity}. The dependency set is the set of functions being called by \textit{f} and is constructed by parsing the program's Abstract Syntax Tree~\cite{pitidis2010purity}.

Their analysis starts with Erlang's so called built-in-functions (BIFs), which are functions native to the Erlang's virtual machine and are written in C~\cite{pitidis2010purity}. Impure actions in Erlang can only be done through BIFs, including performing I/O actions or writing to global variables~\cite{kostis-email}. Because BIFs are written in C they cannot be analyzed by their analysis tool~\cite{pitidis2010purity}. Similarly to CsPurity, Pitidis and Sagonas hard-code the purity levels of some BIFs to be either pure or impure~\cite{pitidis2010purity}. Their analysis classifies all other BIFs as impure~\cite{pitidis2010purity}. The analysis propagates the impurity of BIFs to each function which directly or indirectly depends on them~\cite{pitidis2010purity}.

In short terms, their analysis algorithm works like this: Initialize the purity of all functions in the lookup table to be analyzed to "pure"~\cite{pitidis2010purity}. Define the \textit{working set} to always equal the set of functions whose purity level is fully determined, i.e. the functions with empty dependency sets~\cite{pitidis2010purity}. For each function \textit{f} in the working set, propagate its purity level to functions depending on it and "contaminate" them with \textit{f}'s purity level~\cite{pitidis2010purity}. Then remove \textit{f} from the  dependency set of each function depending on it~\cite{pitidis2010purity}. If \textit{f} has the highest impurity level, remove the entire dependency set of each function depending on \textit{f}~\cite{pitidis2010purity}. If the working set gets empty, find a set of functions that are dependent on each other and no other functions, and set their purity level to the purity of the impurest function~\cite{pitidis2010purity}. Simplify their dependency sets by removing their dependency on each other from their dependency set~\cite{pitidis2010purity}. Repeat this process until there are no more changes to the lookup table~\cite{pitidis2010purity}.

The foundation for the analysis method used in this paper is based off the method developed by Pitidis and Sagonas: The approach with using a lookup table to store the intermediate states of the analysis, dependency sets and propagation of impurity from callee to caller using dependency sets. However, the analysis by Pitidis and Sagonas is intended for programs written in Erlang, which is a functional programming language.
Since C\# as an object-oriented programming language it is quite different from Erlang, and because of this the analysis used in this thesis does some things differently. For instance, this thesis uses different impure purity levels -- \textit{impure}, \textit{locally impure} and \textit{parametrically impure} -- to adapt the analysis to the object-oriented paradigm.

\subsection{JPure: A Modular Purity System for Java} \label{sub:JPure: A Modular Purity System for Java}

David J. Pearce built a purity system and analyzer for Java in his paper JPure: a modular purity system for Java~\cite{pearce2011jpure}. The system uses the properties \textit{freshness} and \textit{locality} to increase the system's ability to classify methods as pure~\cite{pearce2011jpure}. An object is fresh if it is newly allocated inside a method~\cite{pearce2011jpure}. An object's locality is its local state~\cite{pearce2011jpure}. Pearce's definition of a pure method is one that does not assign (directly or indirectly) to any field that existed before the method was called~\cite{pearce2011jpure}.

The system uses the purity annotations \texttt{@Pure}, \texttt{@Local} and \texttt{@Fresh}~\cite{pearce2011jpure}. The annotation \texttt{@Pure} indicates that a method is pure~\cite{pearce2011jpure}. \texttt{@Local} indicates that a method only modifies an object's locality~\cite{pearce2011jpure}. \texttt{@Fresh} indicates that a method only returns fresh objects~\cite{pearce2011jpure}. These three annotations are modularly checkable, i.e. one method's purity annotations to be checked in isolation from all other methods~\cite{pearce2011jpure}.

The system consists of two parts, \textit{purity inference} and \textit{purity checker}~\cite{pearce2011jpure}. Purity inference adds \texttt{@Pure} annotations (and any auxiliary annotations required) to the code and is intended to be run once because it is more costly~\cite{pearce2011jpure}. The purity checker checks the correctness of all annotations at compile-time, and is intended to be used continuously to maintain the code's purity~\cite{pearce2011jpure}.

Pearce's definition of functional purity does not include determinism, unlike the one used in this thesis. The purity level \textit{locally impure} used in this thesis is based on Pearce's \texttt{@Local} attribute. Moreover, the solution to method overriding used in this thesis in \autoref{sub:inheritance} is also based on the ideas developed by Pearce. However, Pearce's approach requires that the program is modularly checkable, i.e. that each method's purity can be evaluated independently of all other methods, and uses annotations to achieve this~\cite{pearce2011jpure}.  Pearce does not introduce an \textit{unknown} purity level for called methods (referred to as methods from external packages) that are not analyzed, but assumes conservatively that such methods are always impure~\cite{pearce2011jpure}.

% Their analysis seems way more complicated than mine, which could be an advantage

\subsection{Purity and Side Effect Analysis for Java Programs} \label{sub:Purity and Side Effect Analysis for Java Programs}

Similarly to Pearce, Alexandru S\u{a}lcianu and Martin Rinard presented a method for analysing purity in Java programs, but their definition of purity also only includes side effects and does not look at the input or output, i.e. does not include determinism~\cite{salcianu}. Their pointer analysis is based on tracking object creation and updates, as well as updates to local variables, and defines methods that mutate memory locations that existed before a method call as impure~\cite{salcianu}. Moreover, their analysis can recognize purity-related properties for impure methods, including \textit{read-only} and \textit{safe} parameters~\cite{salcianu}.

The analysis method presented looks at each program point in each method \textit{m}, and computes a points-to graph modelling the parts of the heap that method \textit{m} points to, represented by nodes in the graph~\cite{salcianu}. There are three kinds of nodes: \textit{Inside nodes} which model objects created by \textit{m}, \textit{parameter nodes} which model objects passed to \textit{m} as arguments, and \textit{load nodes} modelling objects read from outside \textit{m}~\cite{salcianu}. Edges in the points-to graph model heap references~\cite{salcianu}. There are two types of edges: \textit{inside edges} which model heap references created by \textit{m}, and \textit{outside edges} modelling heap references read by \textit{m} from outside it (this includes \textit{m}'s parameters)~\cite{salcianu}.

% For each method \textit{m} the analysis computes a set $W_m$ containing the mutated fields that are externally visible.

The analysis also keeps track of \textit{globally escaped nodes}, which are nodes that may be accessed by unknown code, i.e. passed as argument to native methods or pointed to static fields~\cite{salcianu}. Since globally escaped nodes may be mutated by unknown code, the analysis has to handle them conservatively~\cite{salcianu}.

To check if a method \textit{m} is pure, the analysis computes the set \textit{A} consisting of nodes reachable from parameter nodes along outside edges~\cite{salcianu}. In other words, \textit{A} represents all objects existing before executing \textit{m}~\cite{salcianu}. \textit{m} is pure if and only if no node in \textit{A} escapes globally (i.e. is accessed by unknown code) and no fields in any node in \textit{A} is modified~\cite{salcianu}. There is one exception to the purity constraint: constructors are allowed to mutate fields of the \texttt{this} object~\cite{salcianu}. Therefore, all mutated abstract fields of \texttt{this} are ignored by the analysis~\cite{salcianu}.

Similarly to this thesis, S\u{a}lcianu and Rinard explicitly mark parts of a method that are potentially accessed by unknown code, and deal with them conservatively. Their analysis uses a points-to graph to compute the purity of each method, unlike the method in this thesis that uses a lookup-table and checklist.

% Since they do not include determinism in their definition of functional purity, static

% \subsection{Detecting function purity in JavaScript}
% This was a little too difficult to understand, maybe remove from related work?
% Nicolay et al. developed a method of detecting function purity in JavaScript using something called \textit{pushdown analysis}~\cite{purity-in-javascript}. Their definition of functional purity, however, includes only side effects and does not require functions' output to depend purely on their input~\cite{purity-in-javascript}.

% Because everything except for

% \subsection{Writing Pure Code in C\#} \label{sub:Writing Pure Code in Cs}
% In his article \textit{Writing Pure Code in C\#} Massad defines three levels of pure methods~\cite{yacoub-massad-pure-code}:
% \begin{enumerate}
%   \item Pure methods, i.e. methods that do not read or write to instance state variables, or call impure methods.
%   \item Methods that are pure, and that \textit{read} the state of their containing object, or the state of objects that are passed as parameters or created in the current method.
%   \item Methods that are pure, and that \textit{read} or \textit{write} to the state of their containing objects, or to the state of objects created in the current method.
% \end{enumerate}

% \subsection{Evolution of Degree of Purity in Programming Languages} \label{sub:Evolution of Degree of Purity in Programming Languages}
% Rajasekhara Babu et al.~\cite{rajasekharababu2012evolution}.

\subsection{Verifiable Functional Purity in Java} \label{sub:Verifiable-Functional-Purity-in-Java}

In their definition of functional purity Finifter et al. require pure functions to be both side-effect free and \textit{deterministic}~\cite{purity-in-java}. A function is deterministic if any two evaluations of it have the same result~\cite{purity-in-java}. This means that a deterministic function is one that relies purely on its arguments~\cite{purity-in-java}. A function is side-effect free if it only modifies objects that were created during its execution~\cite{purity-in-java}.

The language that their analyzer handles is a subset of Java, in which they can prove functional purity~\cite{purity-in-java}. If a method is written in this subset of Java and its parameters are immutable, including the implicit \texttt{this}, then the method is pure~\cite{purity-in-java}. % page 166
If its class is immutable it means that a method's global scope has a constant state, and so the only varying state is the one observable through its arguments~\cite{purity-in-java}.

Their verifier has a whitelist of fields and methods from Java libraries that do not expose the ability to observe a global mutable state, or provide access to nondeterminism, and it will reject any reference to a field or method that is not on the list~\cite{purity-in-java}. This is similar to the approach with a list of impure built-in C\# methods used in this thesis and mentioned in \autoref{sub:Impure-built-in-methods}.

Finifter et al. use the same definition of functional purity that is used in this thesis. The main disadvantage with Finifter et al.'s approach is that it requires the code to be written in a subset of Java code in order to be able to analyze the code.

\subsection{Dynamic Purity Analysis For Java Programs} \label{sub:Dynamic Purity Analysis For Java Programs}

In their paper Xu et al. define four different definitions for functional purity, and they are as follows from the strongest to the weakest definition: \textit{strong}, \textit{moderate}, \textit{weak} and \textit{once-impure} purity~\cite{xu2007dynamic}, similarly to the purity levels presented in this thesis in \autoref{def:functional-purity}, \autoref{def:locally-impure} and \autoref{def:parametrically-impure}. Their strongest definition, \textit{strong purity}, includes both determinism and side-effect freeness~\cite{xu2007dynamic}. Moreover, any read from or write to the heap is not allowed in strong impurity~\cite{xu2007dynamic}. Therefore, Xu et al. do not consider reading from object type parameters to be truly pure. \textit{Moderate purity} is like \textit{strong}, except that it also allows modification of newly allocated (i.e. fresh) objects~\cite{xu2007dynamic}. \textit{Weak purity} is like \textit{moderate}, but it also allows non-determinism i.e. reading from objects that exist outside the method~\cite{xu2007dynamic}. \textit{Once-impure purity} is equivalent to \textit{weak purity} except that the first invocation of the method may be impure~\cite{xu2007dynamic}.

It is interesting that Xu et al. do not consider modification of fresh objects or reading the state of object type input parameters as truly pure, which this and most other work does. None of Xu et al.'s purity levels allow modification of input parameters. Xu et al. consider methods that modify their own object \texttt{this} to be impure, but do allow other methods that call such methods and remain \textit{moderately pure}. This is similar to the approach used in this thesis, which classifies the former type of method as \textit{locally impure} and the calling method as \textit{pure} if the called method belongs to a fresh object, as described in \autoref{sub:modifying-fresh-objects}.

Xu et al.'s analysis is performed dynamically which requires looking at Java Virtual Machine code~\cite{xu2007dynamic}. The nature of the dynamic analysis may be the reason why some of their purity definitions differ from most other work, for instance that any modification of any object that was created after the start of executing a method, including fresh ones, is not considered pure by their method of analysis.

\section{Definitions} \label{sec:definitions}

Object-oriented programming and functional programming are two different programming paradigms. There is no universal definition for either of them, but in order to reason about them, we need to choose one. Moreover, since one of the key features of functional programming is functional purity, we have to define that as well.

\subsection{Object-oriented programming} \label{ssub:object-oriented-programming}

\begin{enumerate}
\item Computations are done via \textit{methods} belonging to \textit{objects}, whose structure suits the goal of whatever computation we're doing~\cite{john-m-chambers}.
\item Each object has a unique \textit{object identity} which distinguishes it from all other objects~\cite{khoshafian1986object}.
\item Objects are based on \emph{classes}, and objects belonging to a class have a shared set of properties~\cite{john-m-chambers}.
\item Classes can \emph{inherit} from other classes, such that an object of a class is also an object of the inherited class~\cite{john-m-chambers}.
\end{enumerate}

\subsection{Functional purity} \label{ssub:functional-purity-definition}
% Maybe move this before subsection to lead up to this?

Functional purity is a key part of functional programming. Following is the definition of functional purity that will be used in this thesis:

\begin{definition}[Functional purity] \label{def:functional-purity}
  A function is functionally pure if it is \textit{side effect} free and \textit{deterministic}.
\end{definition}

\textit{Side effect} and \textit{determinism} are defined as follows:

\begin{definition}[Side effect] \label{def:side-effect}
  A side effect is any action performed by a function that is visible outside that function~\cite{purity-in-java}.
\end{definition}

\begin{definition}[Determinism] \label{def:determinism}
  A function is deterministic if its output depends only on its input parameters, i.e. the method must return the same value for the same input regardless of the state of the program~\cite{purity-in-java}.
\end{definition}

\subsection{Functional programming} \label{sub:functional-programming}

\begin{enumerate}
  \item All functions are functionally pure~\cite{alvin-alexander}.
  \item Variables are immutable, meaning that their value does not change after being initialized~\cite{alvin-alexander}. % page 3
  \item Functions are first-class and can be higher-order, meaning that functions can be passed to functions as parameters, and can be returned by functions~\cite{jonas-walter}. % page 3
\end{enumerate}

As mentioned in \autoref{sec:related-work}, some related work defines functional purity only as being synonymous with "side-effect free". This definition omits determinism and thereby allows pure functions to read from variables defined outside their scope, which is less functional. Since determinism guarantees that concurrently running functions or programs cannot affect the execution of a deterministic function, excluding it means excluding guaranteed thread-safety~\cite{purity-in-java}. The definition of purity used in this thesis will therefore require pure functions to not only be side-effect free but also to be deterministic. This is the definition of purity that is used by Finifter et al.~\cite{purity-in-java}, Pitidis and Sagonas~\cite{pitidis2010purity} and Alexander~\cite{alvin-alexander}. % page 19
% the first two whose work is mentioned in \autoref{sub:Purity-in-Erlang} and \autoref{sub:Verifiable-Functional-Purity-in-Java}, respectively.
Moreover, requiring pure functions to be both side-effect free \textit{and} deterministic also simplifies the analysis because it means that any symbol used in a function \textit{f} but defined outside \textit{f} makes \textit{f} impure. If we allowed pure functions to be non-deterministic, that would mean that we would have to check each symbol used in \textit{f} to see if it is being written to or if it is only being read before concluding if \textit{f} is pure.

% The notion of purity only being synonymous with side-effect free seems to be more common in computer science, while also requiring determinism seems to be the more mathematical definition.

% \noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}} % -------- Line break --------

% \textbf{*Add a description of the following*}
% \begin{itemize}
%   \item Side effects and referential transparency, which implies purity~\cite{purity-in-javascript}
%   \item Objects: fields and properties % https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members
%   \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/}{Exceptions}.
% \end{itemize}

% % Microsoft has an article on refactoring none-pure C\# code to pure functions \cite{microsoft-refactoring}.

% \textbf{*Things to consider*}

% \begin{itemize}
%   \item Input/output
%   \item Monads
%   \item Call-by-value vs. call-by-reference: % \textit{"For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed. This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object). Call-by-reference is not necessarily required for a function to modify a parameter."} - \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions}{link}.
%   % \item Functions can be locally pure and/or globally pure https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions
%   \item Control flow analysis
%   % \item Could talk about Haskell in which all functions are pure and all values are immutable
%   \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/}{Delegates} and \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions}{anonymous functions}.
%   \item Implicit and explicit variable declarations (C\# handles both)
%   \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/identifier-names}{Identifiers} are the names of types, members variables or namespaces used in source code. They reference \href{https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-semantics#symbols}{symbols}, representing a declared namespace, type, method, field, variable, etc. The compiler's process of associating identifiers with symbols is called \textit{binding}~\cite{microsoft-semantic-analysis}. % TODO explain symbols and identifiers
%   \item Closures and how objects can be considered closures (if fields are \texttt{readonly}?), and whether they should be considered pure.
% \end{itemize}

\section{The C\# language and .NET} \label{sec:the-csharp-language}

C\# is a type-safe object-oriented programming language developed by Microsoft~\cite{albahari2003nutshell}. C\# is syntactically quite similar to C, C++ and Java, and includes features like nullable types, enumerations, higher-order functions, and direct memory access~\cite{intro-to-Csharp}. While C\# historically has been used primarily for writing code for Windows platforms, C\# has recently spread to most other platforms, including mobile, due to its increased cross-platform support~\cite{albahari2003nutshell}.

C\# applications run in the .NET ecosystem~\cite{intro-to-Csharp}. There are multiple implementations of .NET, including .NET Core and the .NET Framework~\cite{intro-to-Csharp}. .NET includes a virtual execution environment called the common language runtime (CLR) on which C\# programs run, as well as a common set of class libraries~\cite{albahari2003nutshell}. Before execution C\# source code is compiled to the so-called intermediate language (IL) and stored on disk~\cite{intro-to-Csharp}. Upon execution, the IL code is just-in-time-compiled to native machine instructions that can be executed by the operating system~\cite{intro-to-Csharp}.

One fundamental part of the .NET ecosystem are so-called assemblies~\cite{assemblies}. An assembly is a unit of types and resources that form a logical building block of functionality~\cite{assemblies}. Assemblies do not contain C\# source code, but IL code~\cite{assemblies-overview}.

Since C\# is object-oriented it has objects, which are instantiated from classes. In object-oriented programming, methods commonly reference the object in which they exist in order to read or modify their object's state. In C\#, and many other object-oriented languages, methods refer to their object using the keyword \texttt{this}~\cite{microsoft-this}.

Similarly to many other programming languages, functions in C\# are generally referred to as \textit{methods}~\cite{albahari2003nutshell}. These two terms will be used interchangeably in this thesis. Each method belongs to a \textit{class}, which is an encapsulation of data and behaviours~\cite{albahari2003nutshell}. C\# also supports anonymous functions~\cite{albahari2003nutshell}.

\subsection{What makes a C\# method pure?} \label{sub:What makes a Cs program functional?}

\autoref{fig:impure-example} and \autoref{fig:pure-example} illustrate two very simple examples of pure and impure code, respectively. The function \texttt{addOne()} in \autoref{fig:impure-example} is impure since it is writing to the variable \texttt{number} which was defined outside \texttt{addOne()}'s scope, which is a side effect. \autoref{fig:pure-example} illustrates how \texttt{addOne()} can be rewritten to a pure function while preserving the program's semantics.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public class Program {
      static int number;

      public static void addOne() {
        number += 1; // this is a side effect
      }

      public static void Main() {
        number = 42;
        addOne();
        Console.WriteLine(number); // outputs 43
      }
    }
  \end{lstlisting}
  \caption{A simple example of \textit{impure} code due to a side effect.}
  \label{fig:impure-example}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public class Program {
      public static int addOne(int number) {
        return number + 1; // this method is now pure
      }

      public static void Main() {
        int number = 42;
        number = addOne(number);
        Console.WriteLine(number); // outputs 43
      }
    }
  \end{lstlisting}
  \caption{This is how \texttt{addOne()} from the example in \autoref{fig:impure-example} can be rewritten and used as a \textit{pure} function.}
  \label{fig:pure-example}
\end{figure}

Another relatively common side effect is modification to function parameters. Since their value is declared before calling the function, modifications to that value will in some cases be visible outside that function. Function parameters preceded with the \texttt{in} keyword are passed by reference and read-only inside the function~\cite{microsoft-in-modifier}. This means that input parameters marked with \texttt{in} cannot be re-assigned inside the function, which may suggest functional purity. Consider the example in \autoref{fig:in-example1}, where the parameter \texttt{number} is preceded by the \texttt{in} keyword. Because of this, modifying it inside the function will cause a compilation error.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int globalValue = 42;
    addOne(globalValue);
    Console.WriteLine(globalValue);

    void addOne(in int number) // note the `in` keyword
    {
      number += 1; // illegal assignment will raise error CS8332
    }
  \end{lstlisting}
  \caption{Assignment to the parameter \texttt{number} which is preceded with \texttt{in} raises a compilation error~\cite{microsoft-in-modifier}.}
  \label{fig:in-example1}
\end{figure}

However, \texttt{in} is not a purity guarantee. Consider the example in \autoref{fig:in-example2}. The \texttt{in} keyword before the argument \texttt{list} ensures that \texttt{list} is read-only. This prevents \texttt{list} from being re-assigned after instantiation, but it doesn't prevent the data structure which \texttt{list} refers to from being modified~\cite{buchanan-static-lists}. In C\# there are two kinds of types: \textit{value types} and \textit{reference types}~\cite{microsoft-types}. Value types directly contain their data, while reference types -- also known as objects -- are simply pointers that refer to the location of their data.  Even though strings are of the reference type they are immutable, meaning that they cannot be modified after being created~\cite{microsoft-strings}. Therefore, value types and strings are passed to methods by value, which means that a method that modifies a value type parameter only modifies it locally, which doesn't affect its purity. However, since \texttt{list} in \autoref{fig:in-example2} is of reference type, \texttt{in} does not prevent \texttt{list}'s referenced data to be modified.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    List<int> globalValue = new List<int>{42};
    addOne(globalValue);
    globalValue.ForEach(Console.WriteLine); // list is now {42, 1}

    void addOne(in List<int> list) // note the `in` keyword
    {
      list.Add(1); // this will _not_ raise an error even though
                   // Add(1) modifies the list
    }
  \end{lstlisting}
  \caption{The expression \texttt{list.Add(1)} which writes a value to \texttt{list} is allowed, even though \texttt{list} is read-only due to its preceding \texttt{in} keyword.}
  \label{fig:in-example2}
\end{figure}

Since the \texttt{in} keyword does guarantee that methods won't modify their input parameters of reference type, \texttt{in} does not ensure side-effect freeness. Therefore, parameters preceeded with \texttt{in} will have to be checked for modifications, just like all other parameters.

\subsection{The .NET abstract syntax tree and the CodeAnalysis library} \label{The .NET Abstract Syntax Tree and the CodeAnalysis library}

% Abstract syntax trees in general
Abstract syntax trees (AST) are the primary data structure used when analysing source, as they encapsulate every piece of information held in the code~\cite{microsoft-work-with-syntax}. The AST generated by Microsoft's code analysis library \texttt{Microsoft.CodeAnalysis} from a given piece of C\# code represents the lexical and syntactic structure of the C\# program~\cite{microsoft-work-with-syntax}. The tree consists primarily of \textit{syntax nodes} which represent syntactic constructs including declarations, statements, clauses and expressions~\cite{microsoft-work-with-syntax}. Each node is derived from the \texttt{Syntax}-\texttt{Node} class~\cite{microsoft-work-with-syntax}. Every node is non-terminal, meaning that it always has children -- either other nodes or \textit{tokens}~\cite{microsoft-work-with-syntax}. Tokens are the smallest syntactic pieces of the program, consisting of keywords, identifiers, literals and punctuation~\cite{microsoft-work-with-syntax}.

% An \textit{expression} consists of zero or more operators with one or more operands, which can be evaluated to a single value, method, object or namespace.
% https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expressions

\subsection{C\# events} \label{sub:Events}

Events are a way for classes or object to notify other classes or objects when something happens~\cite{microsoft-events}. The class raising the event is called the \textit{publisher} and the class handling the event is called the \textit{subscriber} (there can be more than one subscriber)~\cite{microsoft-events}. When an event is raised, the subscriber's handler method is executed~\cite{microsoft-events}. Since events clearly are side effects, a method that raises events or handles events is not considered pure.

\subsection{.NET code contracts and the \texttt{[Pure]} attribute} \label{sub:code-contracts}

.NET code contracts are used to define pre- and postconditions, as well invariants for pieces of code -- some which can be checked statically and some dynamically~\cite{microsoft-code-contracts}. One available code contract is the \texttt{[Pure]} attribute, which is placed in front of a method signature to indicate that the method is pure~\cite{microsoft-code-contracts}. However, current analysis tools do not enforce that methods marked with \texttt{[Pure]} actually are functionally pure~\cite{microsoft-pure-attribute}, and so the attribute does not guarantee functional purity. Microsoft defines pure methods as methods that don't modify any pre-existing state, i.e. methods can only modify objects that were created after the \texttt{[Pure]} method was called~\cite{microsoft-code-contracts}. Note that this definition of functional purity does not include determinism, which the definition used in this thesis, \autoref{def:functional-purity}, does. Therefore, the attribute does not consider reading values outside the function's scope or throwing exceptions as functionally impure. Nor does it guarantee thread-safety, which a definition including both side-effect freeness \textit{and} determinism does~\cite{purity-in-java}.

\subsection{Impure built-in C\# methods} \label{sub:Impure-built-in-methods}

The .NET Framework class library provides access to system functionality as well as a foundation on which .NET applications are built~\cite{microsoft-dotnet-class-library}. However, when function calls are made to the library they are accessed in the form of an assembly, which mean that the called functions have no source code that can be analyzed. As will be discussed in \autoref{sub:results-larger-codebase}, a substantial portion of the functions analyzed are functions that depend on this kind of functions. Functions with no available source-code will in this thesis be referred to as \textit{unknown functions}.

However, since I/O (input/output) operations are always impure we can assume that functions from the .NET Framework class library that handle I/O and the like are impure. This gives us a handful of functions that we know are impure beforehand, either because they have side effects, or because they are non-deterministic. This means that any function analyzed that depends on any of those functions can be assumed to also be impure.

Following are methods that are built into C\# and that are non-deterministic~\cite{dixin2015}:

\begin{itemize}
  \item \texttt{Console.Read}, \texttt{Console.ReadLine}, \texttt{Console.ReadKey}, \texttt{DateTime\allowbreak.Now} and \texttt{DateTimeOffset.Now} depend on the outside world.
  \item \texttt{Random.Next}, \texttt{Guid.NewGuid} and \texttt{System.IO.Path.GetRandom}-\\\texttt{\allowbreak FileName} give random output.
\end{itemize}

The following methods that are built into C\# and that have side effects~\cite{dixin2015}:

\begin{itemize}
  \item \texttt{System.Threading.Thread.Start} and \texttt{Thread.Abort} mutate states.
  % \item \texttt{int.TryParse} and \texttt{Interlocked.Increase}
  \item \texttt{Console.Read}, \texttt{Console.ReadLine}, \texttt{Console-ReadKey}, \texttt{Console.\allowbreak Write} and \texttt{Console.WriteLine} produce console I/O.
  \item \texttt{System.IO.Directory.Create}, \texttt{Directory.Move}, \texttt{Directory.}\\\texttt{Delete}, \texttt{File.Create}, \texttt{File.Move}, \texttt{File.Delete}, \texttt{File.ReadAll\allowbreak }- \texttt{Bytes} and \texttt{File.WriteAllBytes} produce file system I/O.
  \item \texttt{System.Net.Http.HttpClient.GetAsync}, \texttt{HttpClient.Post}- \\\texttt{Async}, \texttt{HttpClinet.PutAsync} and \texttt{HttpClient.DeleteAsync} produce network I/O.
  \item \texttt{IDisposable.Dispose} interacts with the program's environment.
\end{itemize}

\section{Problems with determining purity in object-oriented languages} \label{sec:problems-with-purity-in-oo}

Analyzing functional purity in object-oriented programming languages yields a number of dilemmas. This section describes them, as well as how they were dealt with.

\subsection{Inheritance and method overriding} \label{sub:inheritance}

When calling an object parameter's method, because of inheritance and method overriding we can never be sure of which method implementation will be called.

\begin{figure}
  \centering
  \begin{lstlisting}
    void f(List<string> x) {
      x.Add("Hello");
    }
  \end{lstlisting}
  \caption{Since \texttt{x} can be of any subclass of \texttt{List} we can never be sure of \texttt{x.Add()}'s implementation~\cite{pearce2011jpure}.}
  \label{fig:inheritance-example}
\end{figure}

For instance, because the parameter \texttt{x} in \autoref{fig:inheritance-example} can be of any subclass of \texttt{List} we can not for sure know the implementation of \texttt{x.Add()}, nor therefore can we be certain of \texttt{x.Add()}'s purity. Thus, a static analysis method can not for sure determine \texttt{f()}'s purity by only looking at its definition.

One solution to this that David J. Pearce suggests is to demand that pure methods only are overridden by methods that are also pure~\cite{pearce2011jpure}. Therefore, if a method \textit{m} is overridden by at least one impure method, \textit{m} is classified as impure. Also, if \textit{m} is overridden by at least one method with unknown purity level, \textit{m}'s purity is classified as unknown.

This means that in the example in \autoref{fig:inheritance-example}, the function \texttt{f()} is pure iff all methods that override \texttt{List.Add()} are pure.

\subsection{Modifying a fresh object} \label{sub:modifying-fresh-objects}

If an object \textit{o} is allocated inside the analyzed method \textit{m}, the object \textit{o} is said to be \textit{fresh}~\cite{pearce2011jpure}. To modify \textit{o}'s state we might call a method belonging to \textit{o} that has the side effect of modifying \textit{o}. However, this method should not make \textit{m} impure since \textit{o} is fresh, which means that the modification of \textit{o} is not a side effect of \textit{m}.

\begin{figure}
  \centering
  \begin{lstlisting}
    public List<String> Foo() {
      List<String> list = new List<String>();
      list.Add("hello"); // this changes list's state
      return list;
    }
  \end{lstlisting}
  \caption{\texttt{List.Add()} modifies \texttt{list}, which was declared before calling \texttt{List.Add()}. However, since \texttt{list} is fresh, \texttt{Foo()}'s purity is not affected.}
  \label{fig:fresh-object-example}
\end{figure}

For example, because \texttt{list.Add()} in \autoref{fig:fresh-object-example} modifies the state of \texttt{list}, which is a side effect of \texttt{Add()}, \texttt{Add()} cannot be a pure method. Does that mean that the function \texttt{Foo()} calling \texttt{list.Add()} is also impure, because it calls a non-pure method? In general functions that invoke impure functions are themselves impure. However, this is not the case for \texttt{Foo()}. Recall the definition of purity in \autoref{def:functional-purity}:

\begin{quote}
  \textit{A function is functionally pure if it is side-effect free and deterministic}.
\end{quote}

Because the function \texttt{Foo()} only modifies an object that is fresh, \texttt{Foo()} does not have any side effect. The function is also deterministic since it does not read any value outside the function besides its own parameters, which it in this case doesn't have. This means that \texttt{Foo()} is pure. To solve this we introduce the purity level \textit{locally impure}:

\begin{definition}[Local Impurity] \label{def:locally-impure}
  Any method that is functionally pure except for modifying any of its object's fields is locally impure.
\end{definition}

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public A Foo() { // pure
      A a = new A();
      a.Increment();
      return a;
    }

    public class A {
      public int value = 0;

      public void Increment() { // locally impure
        value++;
      }
    }
  \end{lstlisting}
  \caption{Since \texttt{Foo()} modifies a fresh object with a locally impure method \texttt{Foo()} is still pure.}
  \label{fig:locally-impure-example}
\end{figure}

For example, the method \texttt{Increment()} in \autoref{fig:locally-impure-example} is locally impure because it modifies its object's field \texttt{value} but doesn't have any other side effects. A function that calls a fresh object's locally impure method \textit{m} is not contaminated by \textit{m}'s local impurity.

\begin{figure}
  \centering
  \begin{lstlisting}
    public A Foo() { // pure
      A a = new A();
      A.Increment(a);
      return a;
    }

    public static void Increment(A a) { // parametrically impure
      a.value++;
    }

    public class A {
      public int value = 0;
    }
  \end{lstlisting}
  \caption{Since \texttt{Foo()} modifies a fresh object with a parametrically impure method \texttt{Foo()} is still pure.}
  \label{fig:parametrically-impure-example}
\end{figure}

There is however one more way to modify a fresh object: to pass it as an argument to a method that alters its state. For example, because the method \texttt{Increment()} in \autoref{fig:parametrically-impure-example} modifies its input parameter object it cannot be considered truly pure. However, since \texttt{Foo()} uses \texttt{Increment()} to modify a fresh object \texttt{Foo()} is still pure. I have chosen to categorize methods like this \textit{parametrically impure}:

\begin{definition}[Parametric impurity] \label{def:parametrically-impure}
  Any method that is pure except for modifying the state of a reference type parameter is parametrically impure.
\end{definition}

There are two ways for a method to modify the state of its reference type input parameters: either by mutating a value belonging to a reference type input parameter, i.e. an object's field or property, or the cell of an array; or by calling a locally impure method belonging to a parameter object.

The key thing in both the example where a method \textit{m} calls locally or parametrically impure methods is that they modify a fresh object, which therefore doesn't affect \textit{m}'s purity level. So as long as the analyzed method \textit{m} or any of its called methods don't perform any truly impure action like I/O operations (e.g. writing to a file on the file system) or throw exceptions, \textit{m} is pure.

In Python, which also is an object-oriented programming language, the instance object equivalent to C\#'s \texttt{this} (in Python usually referred to as \texttt{self}) always has to be explicitly listed as the first parameter of a method when declaring it, and gets automatically passed as the method's first argument when the method is called~\cite{python-classes}. Similarly, in C\# the reference to the instance object \texttt{this} is in fact an implicit parameter for all methods~\cite{michaelis2018essential}. This means that a method \textit{m} that reads the value of a field of its own object still is considered deterministic even though that field has not been explicitly added as a method parameter. Recall from \autoref{def:determinism} that \textit{m} is deterministic if \textit{m}'s output depends purely on its input parameters. This still holds with \textit{m}, since its entire object \texttt{this} where that field lives gets implicitly passed as an argument to \textit{m}.

Moreover, the implicit passing of \texttt{this} to every method also implies that any method that is locally impure is also parametrically impure. As \autoref{def:locally-impure} states, a method \textit{m} that is locally impure modifies its object \texttt{this}'s fields. Since \texttt{this} is always the first parameter of any method, this means that modifying a field in \texttt{this} always means modifying a parameter, which implies parametric impurity.

Although local impurity implies parametric impurity, the opposite does always necessarily hold since a method could be parametrically impure without modifying a field in \texttt{this}. Therefore, distinguishing between local and parametric impurity could be of value, for instance when implementing other methods in the same class; since locally impure methods modify the state of their object, and those object-local side effects are visible for methods inside the same object.

\subsection{Non-static property pointing to a static field} \label{sub:non-static-property}

\textit{Properties} in C\# are special \texttt{get} and \texttt{set} methods for reading, computing or writing to values of object fields~\cite{microsoft-properties}. Properties can, just like other fields or methods be set to \texttt{static}, which means that they are assigned to the class rather than any instantiated object. If a method reads from or modifies a static property, that method would be considered to be non-deterministic or to have a side effect, i.e. it would be impure, because static fields are accessible anywhere in a program.

\begin{figure}
  \centering
  \begin{lstlisting}
  public class Foo {
    public Swede gert = new Swede();

    public void Bar() {
      Swede stina = new Swede();
      stina.Nationality = "Norway"; // assignment to non-static field

      Console.WriteLine(gert.Nationality); // prints "Norway"
    }

    public class Swede {
      static string nationality = "Sweden"; // This field is static

      public string Nationality { // This property is non-static
        get { return nationality; }
        set { nationality = value; }
      }
    }
  }
  \end{lstlisting}
  \caption{What looks like a non-static assignment to an object property does in fact mutate a static field, which is a clear side effect of \texttt{Bar()}.}
  \label{fig:non-static-property-example}
\end{figure}

However, properties can also be non-static but still read or modify static fields. In the example in \autoref{fig:non-static-property-example}, the method \texttt{Bar()} assigns to the field \texttt{Nationality} of the fresh object \texttt{stina}. Because the property \texttt{Nationality} is non-static it, it might look like a pure action at a first glance. But since the property writes method \texttt{get} itself modifies a static field, the \texttt{Bar()}'s assignment to \texttt{Nationality} is in fact a side effect, which alters all \texttt{Swede} objects' \texttt{Nationality}. Therefore, it is not enough to check if a property is static in order to determine whether a read or write is pure, but the property's \texttt{get} and \texttt{set} have to be checked as well.

% Perhaps ignore cases like this for simplicity?

\subsection{Method overloading} \label{sub:Method-overloading}

While method overloading is not unique to object-oriented programming, it seems appropriate to mention here as well. Method overloading is when multiple method implementations share the same method name but have different function signatures, i.e. return types, parameter types and/or number of parameters~\cite{albahari2003nutshell}. One could consider all overloads to be the same method \textit{m}, since they share the same name. However, this would make it difficult to calculate \textit{m}'s purity level, since one overload of \textit{m} could be pure, while another overload is impure. Which purity level should then be given to \textit{m}?

Instead, when given an overloaded method named \textit{m} the analysis treats each overload of \textit{m} as a unique method, independent of other overloads. This way overloads with different purity levels can co-exist in the result of an analysis. Because overloads by definition share the same name, in order to differentiate them in this thesis the notation $m_1$, $m_2$, $m_3$, ... is used, where $m_1$ denotes the first implementation of the method \textit{m}, $m_2$ denotes the second, and so on.

\section{The analysis method} \label{sec:the-analysis-method}

As established in \autoref{sec:problems-with-purity-in-oo} this thesis defines four functional purity levels: \textit{pure}, \textit{locally impure}, \textit{parametrically impure}, and \textit{impure}. Because in some cases the purity level of a method cannot be determined, for instance when the method's definition is missing, a fifth purity level \textit{unknown} is added as well. This can happen when one method calls another method from an assembly. Assemblies contain IL code, and not C\# source code and can therefore not be statically analyzed. Following is a description of the static analysis method developed and used in this thesis in order to determine the purity level of a program:

Traverse the program's abstract syntax tree (AST) and build the \textit{dependency set} for each function, i.e. the set of calls inside a function. If during the traversal a call or reference to a compiled method or a field is found, mark the caller function's purity as \textit{unknown}.

Since object constructors can perform impure actions just like methods, they are in this section included in the term "function".

Because of the problem with inheritance and method overriding discussed in \autoref{sub:inheritance}, when going through the AST and building the dependency set, if any object parameter's method is overridden by any of its subclasses, add all the overridden methods to the calling function's dependency set. Each function together with its dependency set is stored in a lookup table where the key is the function identifier \textit{f} and the values are \textit{f}'s dependency set $D_f$ as well as \textit{f}'s purity level \textit{p}. The purity of each function is initialized to \textit{pure}, except those that were explicitly marked \textit{unknown}.

Let the \textit{working set} \textit{W} be the set of all functions with empty dependency sets. Whenever a function's dependency set becomes empty, that function is added to \textit{W}. Calculate the purity level for each function in \textit{W} as described in the checklist in \autoref{sub:checklist-to-determine-the-purity-level} below. Then, for each function \textit{f} in \textit{W}, propagate the impurity of those with purity level \textit{impure} or \textit{unknown} to the functions dependent on \textit{f}, "contaminating" them. Remove \textit{f} from the dependency sets of all functions that depend on \textit{f}, as well as from the working set \textit{W}. Add functions that now have empty dependency sets to \textit{W}. Repeat this process until there are no more changes to the lookup table, in which case the analysis is complete. Each function in the lookup table will now have been marked with its corresponding purity level. Because the purity level of each function was initialized to \textit{pure}, any function whose purity level was unaffected by the analysis will be marked \textit{pure} at the end of the analysis.

Ignoring the purity level \textit{unknown}, the other four purity levels can be ordered in terms of impurity, from least impure to most impure, like so: \textit{pure} $<$ \textit{locally impure} $<$ \textit{parametrically impure} $<$ \textit{impure}. A method \textit{m}'s purity level should during the analysis only be updated if the new purity level is less impure than \textit{m}'s current one. For instance, if in an arbitrary instance during the analysis, \textit{m} has the purity level \textit{parametrically impure}, and a check determines its purity level to be \textit{impure}, its purity level should be updated since \textit{impure} is more impure than \textit{locally impure}. However, if for instance another check says that \textit{m} is \textit{locally impure}, its purity level should not be updated since \textit{locally impure} is less impure than \textit{impure}.

\subsection{Checklist to determine the purity level} \label{sub:checklist-to-determine-the-purity-level}

% A method can have multiple impurity levels.
The following is how to determine the purity level \textit{p} for the currently analyzed method \textit{m}.

\begin{enumerate}
  \item If any object field or property of the currently analyzed method \textit{m}'s object is read from or modified, mark \textit{m} as \textit{locally impure}. \label{itm:locally-impure}
    % TODO: mention indirectly modifing fields by modifing variables that point to fields
    %   var foo = field;
    %   foo.bar = null;
  \item If \textit{m} calls a locally impure method belonging to \textit{m}'s object (i.e. \texttt{this}) \textit{m} is marked \textit{locally impure}.
  \item If the method \textit{m} reads or modifies a static field of any class or object, \textit{m} is marked \textit{impure}. This is because reading a static field is a non-deterministic action, and modifying a static field is a side effect since it mutates the field for all instantiations of that object's class. \label{itm:static-impure}
  \item If the method \textit{m} calls a \textit{locally impure} method of an object assigned to a static field of any class or object, \textit{m} is marked \textit{impure}.
  \item If the currently analyzed method \textit{m} calls an input parameter's method $m_p$ and $m_p$ is overridden by any locally impure and/or parametrically impure method, $m_p$ is temporarily marked with the impurities of all the overriding methods in the context of the analysis of the current method \textit{m}. If $m_p$ is overridden by any impure method, \textit{m} is permanently marked as impure.
    % Moreover:
    % \begin{itemize} % Maybe these are covered by other cases?
    %   \item If $m_p$ is overridden by any impure method, \textit{m} is marked impure.
    %   \item If $m_p$ is overridden by any locally impure method, \textit{m} is marked parametrically impure.
    % \end{itemize}
  \item If the analyzed method \textit{m} modifies an input parameter of reference type, mark \textit{m} as \textit{parametrically impure}. This could be done in a couple of ways: \label{itm:parametrically-impure}
    \begin{enumerate}
      \item By calling an object type parameter's method that has been marked as \textit{locally impure}. \label{itm:parametrically-impure-sub1}
      \item By passing an object type parameter as an argument to a method that has been marked as \textit{parametrically impure}. \label{itm:parametrically-impure-sub2}
      \item By directly mutating a parameter object's field or property, or the cell of a parameter array. \label{itm:parametrically-impure-sub3}
    \end{enumerate}
    If \textit{m} does at least one of the above, mark it as \textit{parametrically impure}.
  \item If a method returns \texttt{this} or passes it as an argument to a function it marked \textit{locally impure} since it is dependent on the state of its object, making it non-deterministic.
  \item Any method that raises an event is marked \textit{impure}. \label{itm:raises-event}
  \item Any method that raises an exception is marked \textit{impure}. \label{itm:raises-exception}
  \item Any method mentioned in the two lists of impure built-in C\# methods in \autoref{sub:Impure-built-in-methods} is marked \textit{impure}. \label{itm:impure-built-in}
  % \item Build a lookup table with all evaluated functions, their purity and their dependency set~\cite{pitidis2010purity}.
\end{enumerate}

We do not have to explicitly handle the case mentioned in \autoref{sub:modifying-fresh-objects} where fresh objects are modified with their own locally impure methods due to the fact that our definition of local purity includes determinism. Because if a non-fresh object \textit{o} is modified with its locally impure method, then we must have read the pointer to \textit{o} from a field outside the method, meaning that \textit{m} is non-deterministic and therefore locally impure. This is why we only propagate the purity level of \textit{impure} functions to their callers, and not \textit{local impurity} or \textit{parametric impurity}. There are however two exceptions to this, which are covered by previously mentioned checks in our analysis:
\begin{itemize}
  \item The case of \textit{o} being a static field of an instantiated object has to be checked.
  \item The case of \textit{o} being a parameter to \textit{m} has to be checked because this is parametric impurity.
\end{itemize}

\subsection{Example} \label{ssub:example}

\autoref{fig:example-code} contains a simple linked list implementation in C\#. The method \texttt{Length()} takes a \texttt{LinkedList} as input and returns its length. This method is deterministic since it only depends on its input argument, and it is side-effect free since it does not mutate any value that exists outside its scope, including its parameter object. Therefore, \texttt{Length()} is pure.

\texttt{Add()} appends an \texttt{Object} to the end the list. It is not deterministic since it reads from and mutates the state of \texttt{this} in multiple locations. For instance, the first location where it modifies \texttt{this} is where it assigns a \texttt{new Node} to \texttt{head}, which is a field that is visible outside the method. Therefore, \texttt{Add()} is locally impure -- it depends on and/or mutates the state of its object.

\texttt{Remove()} deletes an item at a given index from a \texttt{LinkedList} which is passed as an argument to the method. To simplify the method and reduce its size, its input list is assumed to be non-empty and the index value is assumed to be a valid position inside the list. \texttt{Remove()} only operates based on its input and is therefore deterministic. However, it does modify fields of the parameter \texttt{list} and is therefore parametrically impure.

The first overloading of the method \texttt{Concatenate()} modifies the static class field \texttt{numberOfConcatenates} and therefore has a side effect, making it impure. The second overloading of \texttt{Concatenate()} depends on the former method, and is therefore also impure. The static field \texttt{numberOfConcatenates} was added to illustrate the propagation of impurity.

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{0.52\linewidth}
    \begin{lstlisting}[basicstyle={\fontsize{8}{9}\ttfamily}]
  using System;

  public class LinkedList
  {
    private Node head;
    private Node tail;

    // Static counter used by Concatenate()
    public static int numberOfConcatenates;

    // Returns length of list
    public static int Length(LinkedList list)
    {
      Node current = list.head;
      int length = 0;

      while (current != null)
      {
        length++;
        current = current.next;
      }
      return length;
    }

  // Removes item at an index from list.
  // Assumes that list is non-empty and
  // that index is non-negative and less
  // than list's length
  public static void Remove(int index, LinkedList list)
  {
    if (index == 0) {
      list.head = list.head.next;
    }
    else {
      Node pre = list.head;

      for (int i = 0; i < index - 1; i++)
      {
        pre = pre.next;
      }
      pre.next = pre.next.next;

      // If index referes to the last element
      if (index == Length(list))
      {
          list.tail = pre;
      }
    }
  }
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{0.46\linewidth}
    \begin{lstlisting}[basicstyle={\fontsize{8}{9}\ttfamily}]
  // Appends data to the list
  public void Add(Object data)
  {
    if (LinkedList.Length(this) == 0)
    {
      head = new Node(data);
      tail = head;
    }
    else
    {
      Node addedNode = new Node(data);
      tail.next = addedNode;
      tail = addedNode;
    }
  }

  // Concatenates two lists by
  // appending a list to the end of
  // this list
  public void Concatenate(LinkedList list)
  {
    if (head == null) head = list.head;
    else
    {
      this.tail.next = list.head;
      this.tail = list.tail;
      list.head = this.head;

      // This gives the method a
      // side effect
      numberOfConcatenates++;
    }
  }

  // Overloading of Concatenate that
  // allows passing both lists as
  // parameters
  public static void Concatenate(LinkedList l1, LinkedList l2)
  {
    l1.Concatenate(l2);
  }

  private class Node
  {
    public Node next;
    public Object data;

    public Node(Object data)
    {
      this.data = data;
    }
  }
}
    \end{lstlisting}
  \end{minipage}
  \caption{Simple implementation of a linked list. For the sake of this example, it contains some odd design choices and inconsistencies.}
  \label{fig:example-code}
\end{figure}

The analysis starts off by building the dependency set for each function and setting all purities to \textit{pure}, as seen in \autoref{tab:lookup-table1}.

\begin{table}[H]
  \caption{Initial state of the lookup table after computing each function's dependency set. The working set $W$ is the set of all functions with empty dependency sets.}
  \label{tab:lookup-table1}
  \centering
  \begin{tabular}{|l|c|c|}
    \hline
    $f$                         & $D_f$                     & $p$    \\ \hline
    \texttt{Length()}           &                           & \textit{pure} \\
    \texttt{Remove()}           & \texttt{Length()}         & \textit{pure} \\
    \texttt{Add()}              & \texttt{Length()}         & \textit{pure} \\
    \texttt{Concatenate$_1()$}   &                           & \textit{pure} \\
    \texttt{Concatenate$_2()$}   & \texttt{Concatenate$_1()$} & \textit{pure} \\ \hline
  \end{tabular}
  \\
  $W$ = \{\texttt{Length()}, \texttt{Concatenate$_1()$}\}
\end{table}

The working set $W$ is the set of all functions in the lookup table with empty dependency sets, which in this case is \texttt{Length()} and \texttt{Concatenate$_1()$} (the first overloading of \texttt{Concatenate()} in \autoref{fig:example-code}). We now go through each item in the checklist in \autoref{sub:checklist-to-determine-the-purity-level} for each method in $W$, and check which items apply to the methods:

Since none of the items in the checklist apply to \texttt{Length()}, its purity level remains \textit{pure}. As for the method \texttt{Concatenate$_1()$} the items \ref{itm:locally-impure}, \ref{itm:static-impure} and \ref{itm:parametrically-impure} apply to it. Item \ref{itm:parametrically-impure} since \texttt{Concatenate$_1()$} modifies the fields \texttt{list} and \texttt{tail} of its input parameter, item \autoref{itm:locally-impure} since it modifies its own \texttt{head} and \texttt{tail}, and \autoref{itm:static-impure} since \texttt{Concatenate()} modifies the static class field \texttt{numberOfConcatenates}. Thus, \texttt{Concatenate$_1()$} should be marked with the purity levels \textit{locally impure}, \textit{parametrically impure} and \textit{impure}, and since \textit{impure} is the impurest of the three the method gets marked \textit{impure}.

Since \texttt{Concatenate$_1()$}'s purity level was marked \textit{impure} its purity level is propagated to its callers, which in this case is \texttt{Concatenate$_2()$}. \texttt{Concatenate$_1()$} is then removed from the dependency set of \texttt{Concatenate$_2()$}, and \texttt{Length()} is removed from \texttt{Add()} and \texttt{Remove()}'s dependency sets. The methods \texttt{Length()} and \texttt{Concatenate$_1()$} are now removed from the working set $W$, and \texttt{Remove()}, \texttt{Add()} and \texttt{Concatenate$_2()$} are added to $W$, as their dependency sets now are empty. At this point the state of the lookup table is as shown in \autoref{tab:lookup-table2}.

\begin{table}[H]
  \caption{\texttt{Remove()} and \texttt{Concatenate$_1()$}'s purity levels have been updated, and after analysing them they are removed from the dependency set of their callers. Also, \texttt{Concatenate$_1()$}'s purity level has been propagated to \texttt{Concatenate$_2()$}.}
  \label{tab:lookup-table2}
  \centering
  \begin{tabular}{|l|c|c|}
    \hline
    $f$                        & $D_f$                  & $p$                            \\ \hline
    \texttt{Length()}          &                        & \textit{pure}                         \\
    \texttt{Remove()}          &                        & \textit{parametrically impure}        \\
    \texttt{Add()}             &                        & \textit{pure}                         \\
    \texttt{Concatenate$_1()$}  &                        & \textit{impure}                       \\
    \texttt{Concatenate$_2()$}  &                        & \textit{impure}                       \\ \hline
  \end{tabular}
  \\
  $W$ = \{\texttt{\texttt{Remove()}, Add()}, \texttt{Concatenate$_2()$}\}
\end{table}

Now we perform the same actions again with the new working set $W$ = \{\texttt{Remove()}, \texttt{Add()}, \texttt{Concatenate$_2()$}\}, starting with \texttt{Remove()}. Out of the items in the checklist in \autoref{sub:checklist-to-determine-the-purity-level}, \autoref{itm:parametrically-impure} applies since \texttt{Remove()} directly mutates its input parameter \texttt{list} in multiple locations. Therefore, \texttt{Remove()} is marked \textit{parametrically impure}.

As for \texttt{Add()} \autoref{itm:locally-impure} applies to it since \texttt{Add()} modifies its object in multiple locations, for instance by assigning to the field \texttt{tail}, and so \texttt{Add()}'s purity level is set to \textit{locally impure}.

Looking at \texttt{Concatenate$_2()$}, none of the items in the checklist apply, and so it remains its purity level \textit{impure} that was propagated to it from \texttt{Concatenate$_1()$}.

\texttt{Remove()}, \texttt{Add()} and \texttt{Concatenate$_2()$} are then removed from $W$.

\begin{table}[H]
  \caption{\texttt{Add()}'s purity level has been updated to \textit{locally impure}. Since $W$ is now empty, this is the final result of the analysis.}
  \label{tab:lookup-table3}
  \centering
  \begin{tabular}{|l|c|c|}
    \hline
    $f$                        & $D_f$                  & $p$                            \\ \hline
    \texttt{Length()}          &                        & \textit{pure}                         \\
    \texttt{Remove()}          &                        & \textit{parametrically impure}        \\
    \texttt{Add()}             &                        & \textit{locally impure}               \\
    \texttt{Concatenate$_1()$}  &                        & \textit{impure}                       \\
    \texttt{Concatenate$_2()$}  &                        & \textit{impure}                       \\ \hline
  \end{tabular}
  \\
  $W$ = \{\}
\end{table}

At this point the working set $W$ is empty, and so there can be no more changes to the lookup table. Therefore, the analysis stops here. The final result is thus what is shown in the lookup table in \autoref{tab:lookup-table3}. Looking at the table we can see that \texttt{Length()} is the only truly pure method out of the five. Thus, we can conclude that \texttt{LinkedList}'s total purity level is 1/5 = 20\% functionally pure.

\section{Implementation of the code analysis tool CsPurity} \label{sec:implementation-of-cspurity}

% TODO: Add link to GitHub repo

The implementation of the code analysis tool is called \textit{CsPurity} and is built using .NET Core and C\#. It can be compiled, run and tested from the command line using the command \href{https://docs.microsoft.com/en-us/dotnet/core/tools/}{\texttt{dotnet}}, followed by \texttt{run}, \texttt{build} or \texttt{test}, respectively. Upon calling the program it can be provided either with a single file to be analyzed, or a directory. In the second case, all C\#-files in the directory and all sub-directories are analyzed as one program.

CsPurity works backwards through the analyzed program's function dependencies and for each function visited that function's functional purity level is calculated. The purity levels \textit{impure} and \textit{unknown} also get propagated from callee to caller. Out of all ten items in the checklist in \autoref{sub:checklist-to-determine-the-purity-level}, the following were implemented:

\begin{itemize}
  \item \Autoref{itm:static-impure}: "If the method \textit{m} reads or modifies a static field of an object, \textit{m} is marked \textit{impure}".
  \item \Autoref{itm:raises-exception}: "Any method that raises an exception is marked \textit{impure}".
  \item \Autoref{itm:impure-built-in}: "Any method mentioned in the two lists of impure built-in C\# methods in \autoref{sub:Impure-built-in-methods} is marked \textit{impure}".
\end{itemize}

  % \Autoref{itm:parametrically-impure}: If the analyzed method \textit{m} modifies an input parameter of reference type, mark \textit{m} as \textit{parametrically impure}

Additionally, the items \ref{itm:locally-impure} and \ref{itm:parametrically-impure-sub3} were partially implemented in CsPurity by looking at all assignments in a method and determining if the assigned identifier is declared inside or outside the method. If any identifier is declared outside the method it gets marked \textit{impure}. Therefore, the purity levels \textit{parametrically impure} and \textit{locally impure} were not implemented in CsPurity.

The reason why not all items were fully implemented in CsPurity was due to the sheer amount of time that the implementation took. After implementing the whole lookup table and all of its functionality, calculation of each method's dependency set, propagation of impurities from callee to caller, etc. there was no time left to implement every item in the checklist in a reasonable amount of time, and so the items above were chosen. Because of this, CsPurity cannot classify methods into \textit{locally} or \textit{parametrically impure}, and can only detect full impurity caused by side effects or reading static fields.

\Autoref{itm:static-impure}, \ref{itm:raises-exception} and \ref{itm:impure-built-in} were priorities because they detect the impurest purity level \textit{impure}, and since it is the most severe impurity level it is therefore arguably the most important one to be able to detect. Moreover, checks for full impurity were estimated to be the least time-consuming ones to implement.

Since there was a clear goal for the software and its requirements, test driven development was used when implementing CsPurity. To find the declaration of symbols the method \texttt{SemanticModel.GetSymbolInfo()} from the code analysis library \texttt{Microsoft.CodeAnalysis} is used, which uses the semantic model of the program. Because .NET has many libraries in the form of pre-compiled assemblies, the source code of the functions used in these libraries is not always available, as discussed in \autoref{sub:Impure-built-in-methods}. Because of this, the purity level \textit{unknown} has to be added for when we cannot compute a function's purity level.

CsPurity is not able to determine the purity of methods that invoke delegate functions. Delegate functions in C\# are higher-order functions that invoke methods passed to them as arguments. The delegate functions themselves however are analyzed just like regular methods.

Something that was realized while implementing CsPurity is that the C\# compiler does not perform tail call recursion. Recursion is a very common technique when it comes to computations on trees, as well as functional programming. The initial implementation of CsPurity built the lookup table by calculating each function's dependency set recursively. When analyzing larger code bases, the program crashed due to an immense memory usage. Therefore, its recursive implementation had to be changed to an iterative one which worked much better performance wise.

\section{Results and discussion} \label{sec:results-and-discussion}

To evaluate CsPurity's accuracy, it was run on the example code in \autoref{fig:example-code} and the result was compared to the one in \autoref{tab:lookup-table3}, which was produced by manually applying the analysis method to the example code. The result of running CsPurity on the example code is in \autoref{sub:results-from-scanning-the-example-list}. CsPurity is also run on a larger code base consisting of 96 725 methods in total in order to evaluate its performance in real life, non-trivial, cases. The code base consists of the 11 most popular open source GitHub repositories that use C\# and the \texttt{[Pure]} attribute in at least 1\% of methods were chosen. The popularity was measured based on the number of stars, which is GitHub's user rating system for repositories. Those results are in \autoref{sub:results-larger-codebase}.

As mentioned in \autoref{sub:code-contracts} the \texttt{[Pure]} attribute can be placed in front of a method definition to signal that the method pure. That means that running CsPurity on a code base where a portion of the methods use the \texttt{[Pure]} attribute CsPurity's accuracy can be evaluated by comparing what the methods with and the methods without the \texttt{[Pure]} attribute were categorized as by CsPurity. It is assumed that any method with the \texttt{[Pure]} attribute is functionality pure. This does not necessarily have to be true in general, and as will be discussed later, a large portion of \texttt{[Pure]} methods do in fact have side effects. But the \texttt{[Pure]} attribute can still tell us something about how CsPurity performs.

In CsPurity's implementation it is also assumed that all methods without \texttt{[Pure]} are impure. There could be exceptions to this, i.e. pure methods that haven't been given the \texttt{[Pure]} attribute by the code's author, and this will also be discussed further in \autoref{sub:discussion}. However, this assumption still lets us say something about CsPurity's ability to classify impure methods. Also, since all 11 repositories were selected specifically because they contain \texttt{[Pure]}'s it is therefore reasonable to assume that most methods without the attribute are impure.

\subsection{Results from scanning simple implementation of linked list} \label{sub:results-from-scanning-the-example-list}

Following is the result of running CsPurity on the linked list program in \autoref{fig:example-code}. By looking at the result from running CsPurity on it and comparing it to the expected result in \autoref{tab:lookup-table3} we can evaluate its performance.

\begin{figure}[htpb]
  \centering
  \begin{minipage}{\linewidth} % Forces code to be on same page
    \begin{lstlisting}
    METHOD                        PURITY LEVEL
    ------------------------------------------
    int LinkedList.Length         Pure
    void LinkedList.Remove        Impure
    void LinkedList.Add           Impure
    void LinkedList.Concatenate   Impure
    void LinkedList.Concatenate   Impure
    \end{lstlisting}
  \end{minipage}
  \caption{Result from running CsPurity on the linked list implementation in \autoref{fig:example-code}.}
  \label{fig:example-result}
\end{figure}

As seen in \autoref{fig:example-result} CsPurity correctly identifies the purity level of the \texttt{Length()} as \textit{pure}, meaning that the method passed all impurity checks and got to keep its initial purity level \textit{pure}. It also successfully identifies the full impurity of both overloads of \texttt{Concatenate()} whose implementations can be seen in \autoref{fig:example-code}. CsPurity has thereby successfully spotted the first overload's side effect and propagated its impurity to the second overload, which depends on the first.

As for the methods \texttt{Remove()} and \texttt{Add()}, their purity levels resulted in \textit{impure} in \autoref{fig:example-result}, while the analysis result in \autoref{tab:lookup-table3} is \textit{parametrically impure} and \textit{locally impure}, respectively. Here we see that although CsPurity does not explicitly categorize into parametric or local impurity, it still covers those cases by classifying basic parametrically and locally impure methods as \textit{impure}.

\subsection{Results from running CsPurity on a large codebase} \label{sub:results-larger-codebase}

The results from running CsPurity on each of the 11 repositories are divided into two different tables; \autoref{tab:results-pure-methods} which contains CsPurity's classification for methods with the \texttt{[Pure]} attribute, and \autoref{tab:results-non-pure-methods} with the result for methods without the attribute. Methods with the \texttt{[Pure]} attribute make up 47\% percent of the total number of methods analyzed, and so 53\% of methods do not have the attribute. \autoref{tab:results-summary} contains the distribution of purity levels for all analyzed methods, and \autoref{tab:results-precision-recall} contains CsPurity's precision and recall based on the numbers in \autoref{tab:results-pure-methods} and \autoref{tab:results-non-pure-methods}. Precision is the number of true positives in relation to the number of selected items. Recall (or sensitivity) is the number of true positives in relation to all relevant items (the items that should be selected).
% CsPurity's precision in terms of classifying pure methods is equal to the number of \textit{pure} methods with a \texttt{[Pure]} attribute divided by the total number of methods that are classified as \textit{pure}. CsPuritiy's recall in terms of pure methods is the number of \textit{pure} methods with a \texttt{[Pure]} attribute divided by

% Data generated by CsPurity commit 1c2d28

\begin{table}[H]
  \small
  \caption{CsPurity's classification of the methods with the \texttt{[Pure]} attribute after being run on 11 different open source repositories.}
  \label{tab:results-pure-methods}
  \centering
  \begin{tabular}{|l|lp{2.8cm}p{1.4cm}l|l|}
    \hline
    \textbf{Repository name} & \textbf{Pure} & \textbf{Impure:\newline throws exception} & \textbf{Impure: other} & \textbf{Unknown} & \textbf{Total} \\
    \hline
    nodatime                & 42   & 23   & 82    & 14   & 161   \\
    WindowsCommunityToolkit & 42   & 22   & 139   & 65   & 268   \\
    CsConsoleFormat         & 31   & 16   & 23    & 28   & 98    \\
    opentk                  & 119  & 15   & 444   & 100  & 678   \\
    opencvsharp             & 0    & 0    & 32    & 2591 & 2623  \\
    nuke                    & 4    & 114  & 17243 & 57   & 17418 \\
    linq2db                 & 5    & 105  & 20    & 29   & 159   \\
    language-ext            & 1337 & 947  & 16960 & 4609 & 23853 \\
    MetadataExtractor .NET  & 8    & 0    & 39    & 16   & 63    \\
    Spreads                 & 0    & 31   & 3     & 1    & 35    \\
    fluentassertions        & 57   & 0    & 4     & 16   & 77    \\
    \hline
    \rowcolor{lightgray} \textbf{Total number of methods} & 1645 & 1273 & 34989 & 7526 & \cellcolor{white} 45433 \\
    \rowcolor{lightgray} \textbf{Total percentage}        & 4\%  & 3\%  & 77\%  & 17\% & \cellcolor{white} 100\% \\
    \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \small
  \caption{CsPurity's classification of the methods with no \texttt{[Pure]} attribute after being run on 11 different open source repositories.}
  \label{tab:results-non-pure-methods}
  \centering
  \begin{tabular}{|l|lll|l|}
    \hline
    \textbf{Repository name} & \textbf{Pure} & \textbf{Impure} & \textbf{Unknown} & \textbf{Total} \\
    \hline
    nodatime                & 276  & 2804  & 677   & 3757  \\
    WindowsCommunityToolkit & 326  & 5110  & 1863  & 7299  \\
    CsConsoleFormat         & 128  & 430   & 325   & 883   \\
    opentk                  & 120  & 1420  & 848   & 2388  \\
    opencvsharp             & 164  & 2624  & 892   & 3680  \\
    nuke                    & 545  & 2156  & 399   & 3100  \\
    linq2db                 & 1045 & 8874  & 3008  & 12927 \\
    language-ext            & 670  & 5558  & 1897  & 8125  \\
    MetadataExtractor .NET  & 100  & 1317  & 227   & 1644  \\
    Spreads                 & 205  & 1379  & 317   & 1901  \\
    fluentassertions        & 710  & 4075  & 803   & 5588  \\
    \hline
    \rowcolor{lightgray} \textbf{Total number of methods} & 4289 & 35747 & 11256 & \cellcolor{white} 51292 \\
    \rowcolor{lightgray} \textbf{Total percentage}        & 8\%  & 70\%  & 22\%  & \cellcolor{white} 100\% \\
    \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \small
  \caption{The ratio of CsPurity's classification of all analyzed methods, i.e. both methods with and without the pure \texttt{[Pure]} attribute.}
  \label{tab:results-summary}
  \centering
  \begin{tabular}{|l|lll|l|}
    \hline
                        & \textbf{Total \# of Pures} & \textbf{Total \# of Impures} & \textbf{Total \# of Unknowns} & \textbf{Total} \\
    \hline
    \textbf{Amount}     & 5934 & 72009 & 18782 & 96725 \\
    \textbf{Percentage} & 6\%  & 74\%  & 19\%  & 100\% \\
    \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \caption{Precision and recall of CsPurity's classification of pure and impure methods.}
  \label{tab:results-precision-recall}
  \begin{tabular}{|l|ll|}
    \hline
                                          & \textbf{Precision} & \textbf{Recall} \\
    \hline
    \textbf{Pure method classification}   & 28\%               & 4\%             \\
    \textbf{Impure method classification} & 50\%               & 70\%            \\
    \hline
  \end{tabular}
\end{table}

As seen in \autoref{tab:results-summary}, 19\% of all methods were classified with the purity level \textit{unknown}, meaning that their purity levels could not be determined by CsPurity. This will typically occur when a method depends on a method from an imported library that lacks C\# source code like an assembly. This portion of \textit{unknowns} somewhat contributes to the low recall for CsPurity that is seen in \autoref{tab:results-precision-recall}, in particular when it comes to classifying pure methods.

The data set is somewhat nonuniform, primarily in \autoref{tab:results-pure-methods}. The two by far most impactful repositories are \textit{language-ext} and \textit{nuke} which together make up over half of the code base (54\%) in terms of number of methods. The majority of \texttt{[Pure]} methods in \textit{language-ext} and \textit{nuke} were classified as \textit{impure} by CsPurity, and those methods contribute to 97\% of all \texttt{[Pure]} methods classified as \textit{impure} by CsPurity. In order to compensate for this we normalize the purity levels of CsPurity's classification for each repository and calculate the recall and precision based on those normalized values.

To normalize the amount of methods with the attribute $a \in \{\texttt{[Pure]}, \text{non-}\texttt{[Pure]}\}$, classified as $p \in \{pure, impure, unknown\}$, do the following: For each repository $R$, the number of methods in $R$ classified as $p$ is divided by the total amount of methods with the attribute $a$ in $R$. % This is done for all the combinations of in the \texttt{[Pure]} or non-\texttt{[Pure]} with all
This is done for each combination of $(a, p)$ in \autoref{tab:results-pure-methods} and \autoref{tab:results-non-pure-methods}, which yields the precision and recall shown in \autoref{tab:results-precision-recall-normalized} that demonstrate significantly better performance.

\begin{table}[H]
  \centering
  \caption{Precision and recall of CsPurity's classification of pure and impure methods after normalizing each repository's purity level distribution.}
  \label{tab:results-precision-recall-normalized}
  \begin{tabular}{|l|ll|}
    \hline
                                          & \textbf{Precision (normalized)} & \textbf{Recall (normalized)} \\
    \hline
    \textbf{Pure method classification}   & 65\%                            & 17\%                         \\
    \textbf{Impure method classification} & 54\%                            & 69\%                         \\
    \hline
  \end{tabular}
\end{table}

With a precision and recall based on normalized data each repository's purity level distribution contributes equally. % The non-normalized data assumes that each repository
Since the repositories have different code and different authors that may be varyingly strict with what methods should have the \texttt{[Pure]} attribute it is reasonable to assume that each repository should be viewed as a separate entity, and that each repository therefore should be accounted for evenly.

\subsection{Discussion} \label{sub:discussion}

As discussed in \autoref{sub:code-contracts}, Microsoft's definition of functional purity used for the \texttt{[Pure]} attribute does not include determinism like the definition used in this thesis, \autoref{def:functional-purity}, does. That means that methods that read or modify static fields, or that throw exceptions do not violate the \texttt{[Pure]} attribute. This may at least partially explain why 3\% + 77\% = 80\% of methods in \autoref{tab:results-pure-methods} were classified by CsPurity as \textit{impure} ("Impure: throws exception" and "Impure: other" in the table), despite having the \texttt{[Pure]} attribute. This was confirmed to be the case when looking randomly and manually at smaller samples of methods in each repository as no incorrectly classified method based on \autoref{def:functional-purity} was found.

Moreover, some repositories use \texttt{[Pure]} on methods that only modify their own object \texttt{this} (i.e. what this thesis refers to as \textit{locally impure} methods). For instance, out of all 17 243 \texttt{[Pure]} methods in \texttt{nuke} that were classified as \textit{impure} by CsPurity ("Impure: other"), seen in \autoref{tab:results-pure-methods}, not one could be found that didn't modify its object, despite having the \texttt{[Pure]} attribute. These 80\% false negative \texttt{[Pure]} methods also directly contribute to the low recall for classification of pure methods (17\%), as well as the \textit{impure} classification precision (54\%) as seen in \autoref{tab:results-precision-recall-normalized}.

Moreover, CsPurity's stricter definition of functional purity compared to the \texttt{[Pure]} attribute's, together with 17\% \texttt{[Pure]} \textit{unknowns} also contributes to the low amount of true positives when it comes to pure methods. As seen in \autoref{tab:results-pure-methods} only 4\% of \texttt{[Pure]} methods were classified as \textit{pure} by CsPurity, which explains the low recall for classification of pure methods seen in \autoref{tab:results-precision-recall-normalized}.

Due to the choice of including determinism in the definition of functional purity, which is not included in some definitions, the analysis could be somewhat simplified. The main advantage to including determinism analysis-wise is that one doesn't have to explicitly check whether potentially global (i.e. static) object fields are read from or modified by a function \textit{f}, in order to determine \textit{f}'s purity. As long as a static variable appears in \textit{f} we know that \textit{f} is non-deterministic since it depends on a global state. On the other hand, if determinism were ignored we would have to check whether the static field is modified by \textit{f} or not -- or by some method called by \textit{f} -- in order to determine \textit{f}'s purity, which would be even trickier.

As stated in the beginning of \autoref{sec:results-and-discussion} it is assumed that any method without \texttt{[Pure]} is impure. While this is a necessary assumption in order to be able to say anything about CsPurity's ability to classify impure methods, this is not always the case, and this is reflected in \autoref{tab:results-non-pure-methods} in the 8\% of methods with no \texttt{[Pure]} attribute that were classified as \textit{pure} by CsPurity. While 8\% may not sound like much, in combination with the amount of \texttt{[Pure]} methods classified as \textit{pure} at only 4\% of all \texttt{[Pure]} methods, this significantly impacts the \textit{pure} classification precision which is 65\%, as seen in \autoref{tab:results-precision-recall-normalized}. When manually looking at a small sample of these methods none of the ones looked at performed a non-pure action. Since it is up to the author to explicitly add \texttt{[Pure]} to a pure method, it is reasonable to assume that some pure methods are overlooked.

If C\# had another attribute similar to \texttt{[Pure]} called for instance \texttt{[Impure]}, which explicitly indicated that its method performs a functionally impure action that would make it easier to evaluate CsPurity more fairly. If such an attribute were available and used in the analyzed code base it would likely change numerous of the currently false positives to true positives in regard to impure methods. % Unfortunately no such attribute could be found.

While not nearly as much, the 8\% of methods with no \texttt{[Pure]} attribute also contribute in part to the 69\% impure classification recall seen in \autoref{tab:results-precision-recall-normalized}. However, the most contributing factor reducing the impure classification recall is the 22\% of non-\texttt{[Pure]}s classified as \textit{unknown} in \autoref{tab:results-non-pure-methods}.

As previously mentioned, CsPurity only implements a subset of the analysis method described in \autoref{sec:the-analysis-method}, which is important to keep in mind. This likely has a big, if not the biggest impact on CsPurity's precision and recall. If all items in the checklist in \autoref{sub:checklist-to-determine-the-purity-level} got implemented, we would presumably see an improvement in both recall and precision.

% An alternative way to compare programs' total purity levels, i.e. the ratio between number of pure methods and the total number of methods, could be to profile each program and weight the purity level of each method depending on how often that method is called. For example, let's say that only 10\% of program \textit{A}'s methods are pure compared to program \textit{B} where 20\% of its methods are pure. Now say that \textit{A}'s pure methods make up 90\% of the total function calls during execution and \textit{B}'s pure methods only are called 10\% of the times during execution. In this case, one could argue that \textit{A} is purer than \textit{B} since it makes more calls to pure methods than impure ones compared to \textit{B}, even though \textit{B} has a higher ratio of the number of pure methods.

Since CsPurity is unable to classify methods into locally and parametrically impure, it cannot for certain determine the purity level of any program. CsPurity does however identify true impurity -- the impurest purity level -- and therefore approximates a lower bound to a program's \textit{impurity}. % , which is equivalent to an upper bound to the program's purity level.
CsPurity does not give a definite lower bound to a program's purity though. This is due to the fact that all methods' purity levels are initialized to \textit{pure}, and the purity level only changes if CsPurity detects a non-pure trait based on the checklist in \autoref{sub:checklist-to-determine-the-purity-level}. Since not every item in the checklist is implemented, we cannot know if a method was marked \textit{pure} in the result of an analysis because it truly was pure, or because it had a non-pure trait that the implementation cannot detect. However, CsPurity does cover what are arguably the most common non-pure actions in C\# programs -- reading or modifying static fields, assigning to variables declared outside the method, and raising exceptions. Despite not being fully implemented, CsPurity still shows the potential of the analysis method and could be considered a working prototype that approximates a lower bound to a given program's impurity.

% One could argue that if choosing between computing an upper or a lower bound to a program's purity level, a lower bound is more interesting to a programmer. However, due to the nature of the analysis method this requires fully implementing the analysis method.

Because a large portion of methods use built-in .NET methods for which the source code is not available to CsPurity, nearly a fifth of the analyzed methods get the purity level \textit{unknown}, as seen in \autoref{tab:results-summary}. One way that this was tackled during implementation was to search online for the source code of classes like \texttt{List}, run the analyzer on them and permanently store the calculated purity level for each method in a dictionary in CsPurity, so that whenever a call to a built-in \texttt{List} method is encountered by CsPurity that method's purity level (if it is not \textit{unknown}) can be retrieved from the dictionary. However, this relies on the fact that the source code for a particular built-in method is available, and the process of searching for its code, running the analyzer on it and adding any known result to the program's dictionary is cumbersome. Therefore, a lot of methods are marked as \textit{unknown} by CsPurity because they depend on a method whose source code is not available to, or has been priorly analyzed by CsPurity.

An alternative approach to handling called methods with unknown purity -- as opposed to marking their purity level \textit{unknown} -- would be to simply assume that any unknown method's purity level always is \textit{impure}. The more conservative approach of assuming that any unknown method is impure would mean that the lower bound for the program's total possible impurity level would be moved up, which could potentially give a lower bound that is too high, since some of the unknown methods that were marked \textit{impure} could have been pure. Therefore, since it clearly indicates to the user where the purity level could not be determined, the purity level \textit{unknown} seems to be the best choice here.

\section{Conclusion} \label{sec:conclusion}

% Answer the purpose - metod har utvecklats, den har utvärderas på de här sätten och vi har kommit fram till att det är såhär

Functional purity is perhaps one of the most useful concepts from functional programming that object-oriented programmers can learn from. A function is functionally pure if it is side-effect free and deterministic. In this thesis an analysis method for statically approximating functional purity in C\# source code has been developed. The method categorizes C\# functions into one of the five functional purity levels \textit{pure}, \textit{locally impure}, \textit{parametrically impure}, \textit{impure} or \textit{unknown}. The last purity level, \textit{unknown}, is for methods whose purity level cannot be computed, which can happen if they call a method from an assembly. The analysis method was also implemented in a program called CsPurity as a working prototype of the analysis method. Because CsPurity is a prototype, it only implements a subset of the full analysis method. As a result, it can only detect the impurest purity level \textit{impure}, as well as \textit{unknown}. Therefore, CsPurity approximates a lower bound for the number of impure methods in a given C\# program.

The analysis method was evaluated by running CsPurity on a code base of 11 open source C\# repositories that use the \texttt{[Pure]} attribute, with a total of 96 725 methods. The \texttt{[Pure]} attribute can be placed in front of a function by a programmer in order to indicate that the function is side-effect free. It currently has no effect on the program's compilation or execution. The \texttt{[Pure]} attribute was used in this thesis as reference in order to benchmark CsPurity. After normalizing CsPurity's classification distribution for each repository analyzed its classification of pure functions has a precision of 65\% and recall 17\%, and its classification of impure functions has 54\% precision and 69\% recall.

There are a number of factors that bring down CsPurity's accuracy. The main one is of course the fact that CsPurity only implements a fraction of the full analysis method. Beyond that, 19\% of all analyzed methods receive the purity level \textit{unknown}, i.e. depend on at least one method whose implementation is not available. Moreover, it turns out that some methods that have been given the \texttt{[Pure]} attribute still do have side effects. Also, since the \texttt{[Pure]} attribute only indicates side-effect freeness it does not include the second requirement for functional purity used in this thesis -- determinism. This difference in definition of functional purity between \texttt{[Pure]} and CsPurity also reduces its perceived accuracy when evaluating it using \texttt{[Pure]} as a benchmark.

Despite the limited precision and recall of the prototype, the evaluation still shows the potential of the full analysis method. By adding the remaining parts of the full analysis method to the implementation CsPurity, one could therefore potentially have a fully working system for statically approximating a program's level of functional purity that could be used on any C\# program.

\section{Future work} \label{sec:future-work}

The implementation of CsPurity used in this thesis does not incorporate the full analysis method described in \autoref{sec:the-analysis-method}. Therefore, the obvious next step is to implement the full analysis method in CsPurity.

CsPurity does not handle recursion. Therefore, if a recursive program is analyzed could cause it finish before all functions' purities have been calculated, because no more functions will be added to the working set. Support for recursive functions can be added by searching for independent strongly connected components~\cite{pitidis2010purity}.

One enhancement to CsPurity would be for it to point out the exact position of impurity in the analyzed code. Because impurity is calculated by passing the purity level of impure functions to their callers, this feature could be implemented by also passing the exact position in the code where the impurity was encountered to the caller, as well as the function's identifier and other useful information.

Moreover, the analysis method developed in this thesis could potentially be used to check the validity of a function that uses the \texttt{[Pure]} attribute. As mentioned in \autoref{sub:code-contracts} \texttt{[Pure]} is currently not enforced by any analysis tool, and so illegally assigned \texttt{[Pure]}s can currently not be detected. This could prevent mistakes where the author of a piece of code falsely assigns \texttt{[Pure]} to an impure method from propagating. This could cause bugs to appear if somebody else uses that function unknowingly thinking that it is side-effect free. Of course the analysis method used in this thesis would have to be slightly tweaked to consort with \texttt{[Pure]}'s non-deterministic definition of functional purity.

While likely very difficult to implement, another very useful feature would be if CsPurity after finding an impurity could suggest changes to the code that would make the function in question pure.

As mentioned in \autoref{sec:implementation-of-cspurity}, CsPurity cannot determine the purity level of higher-order function, which in C\# come in the form of so-called delegates. This is another improvement one could add to the analysis method and CsPurity.

\bibliography{references}

%\appendix % markerar att resten är appendix

\end{document}
