% Template taken from https://github.com/independent-project-in-it-uu-2019/rapport-mall/blob/master/rapport-mall.tex

% MUST use a4paper option
% MAY use twoside, smaller font, and other class
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc} % Use UTF-8 encoding in input files
% NOTE: If you are writing in English, un-comment the following line:
\usepackage[swedish,english]{babel}
\usepackage{UppsalaExjobb} % Use the template for thesis reports

\usepackage{amssymb,amsmath,amsthm,amsfonts} % Useful font packages for maths and symbols
\usepackage{listings} % for nice code listings
\usepackage{placeins}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{hyperref}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
}
\urlstyle{same}

% styling of code
% \definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{%frame=tb,
  language=java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\fontsize{10}{11}\ttfamily},
% numbers=left,
% numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=false,
  tabsize=2,
  morekeywords={}
}

% Use one of these:
% - IEEEtranS gives numbered references like [42] sorted by author,
% - IEEEtranSA gives ``alpha''-style references like [Lam81] (also sorted by author)
% \bibliographystyle{IEEEtranSA}
\bibliographystyle{IEEEtranS}
\bstctlcite{IEEEexample:BSTcontrol}
%\bibliographystyle{plainurl}

% Designval: per default används styckesindrag, men ibland blir det snyggare/mer lättläst med tomrad mellan stycken. Det åstadkoms av de följande raderna.
% Tycker ni om styckesindrag mera, kommentera bort nästa två rader.
\parskip=0.8em
\parindent=0mm
% Designval: vill ni ha en box runt figurer istället för strecken som är default, av-kommentera raden nedan. Obs att både \floatstyle och \restylefloat behövs.
\floatstyle{boxed} \restylefloat{figure}
% \floatstyle{plain} \restylefloat{figure}

\begin{document}

% Set title, and subtitle if you have one
\title{To what extent is C\# being used as a functional programming language?}
% Use this if you have a subtitle
\subtitle{An evaluation of functional purity in C\#}
% Set author names, separated by "\\ " (don't forget the space)
% List authors alphabetically by last name (unless someone did significantly more/less)
\author{Melker Österberg}

% Set the date and year - use the right language!
\date{\begin{otherlanguage}{English}  %\foreignlanguage doesn't seem to affect \today?
\today
\end{otherlanguage}}

% Only need to set the year if it differs from the current year
%\year=2018
\handledare{Mikael Axelsson, Erik Löthman}
\reviewer{Konstantinos Sagonas}

% Programnamn på svenska och engelska
\progname{Civilingenjörsprogrammet i Informationsteknologi}{Master Programme in Computer and Information Engineering}

% Utgivare
\enhetsnamn{Institutionen för \\ Informationsteknologi}
%\enhetsnamn{Department of Information Technology}
\besoksadress{ITC, Polacksbacken\\ Lägerhyddsvägen 2}
\postadress{Box 337 \\ 751 05 Uppsala}
\hemsida{http:/www.it.uu.se}

% Set the name of the series, and the number in the series
\seriesname{Master Thesis}
%\seriesname{Independent Project in Information Engineering}
% \seriesname{Uppsatsmetodik}

% OBS: Gäller bara exjobb i årskurs 5
% Get a series number, e.g. from Studentservice Ångström
%\seriesnumber{}
% Use the appropriate ISSN for the series
%\issn{}
% Usually this is where it is printed
%\printer{}

% This creates the title page
\maketitle

% Change to frontmatter style (e.g. roman page numbers)
\frontmatter

\begin{abstract}
  TODO
\end{abstract}

\begin{sammanfattning}
  TODO
\end{sammanfattning}

% Innehållsförteckningen här.
\tableofcontents

% Här kan man också ha \listoffigures, \listoftables

\cleardoublepage

% Change to main matter style (arabic page numbers, reset page numbers)
\mainmatter

\section{Introduction} \label{sec:Introduction}
% https://dl-acm-org.ezproxy.its.uu.se/doi/pdf/10.1145/1455770.1455793?download=true has motivation for using pure functions in its abstract

Functional programming is on the rise and becoming more mainstream~\cite{intertech}. Object oriented (OO) programming has been the industry norm for quite some time now, and for a long time functional programming was considered by developers to only be applicable in academic domains. However it is now becoming popular in the IT industry as well. Many mainstream languages like Java, C\# and C++ have adopted first-class functions from the functional paradigm~\cite{intertech}. Moreover, functional programming can be used for building web applications and mobile apps~\cite{jonas-walter}.

Functional programs have many benefits over purely object oriented ones. Perhaps one of the most useful features of functional programming that the object oriented world of programming could adopt is \textit{functional purity}. Programs with pure functions are generally easier to reason about compared to object oriented ones because they have no \textit{side-effects}~\cite{alvin-alexander}. A side-effect is anything that a function does besides producing a return value and that is visible from the function's caller's point of view~\cite{purity-in-javascript}. Pure functions are also easier to test since all we need to look at are functions' inputs and outputs, which also, for instance, facilitates property-based testing~\cite{alvin-alexander}. Moreover, research has shown that pure programs are easier to debug and maintain~\cite{purity-in-javascript}. % page 1
For this reason it useful in software engineering to evaluate the level of functional purity in programs~\cite{purity-in-javascript}.

C\# is among the top five most popular programming languages~\cite{tiobe}. To its core, it is an object-oriented programming language. However, it has features that allow for functional programming~\cite{hamid-mosalla}. But to what extent is C\# being used as a functional programming language by developers? This paper will attempt to answer this by evaluting to what degree functional purity is used in C\# programs today.

% Yannis Smaragdakis and Brian McNamara showed that there are ways of converting the common OO design patterns Command, Observer, Adaptor, Visitor and Virtual Proxy in C++ to functional programs using FC++ -- a library that adds many functional features to C++~\cite{yannis-smaragdakis}. Would this kind of transformation be useful for programs written in C\#? If C\# is not currently being used primarily as a functional programming language, this tool could be useful to programmers that want to refactor an existing OO program to a functional one.

\section{Background} \label{sec:Background} % (several sections depending on work)

\subsection{Definitions} \label{sub:Definitions}
Following are definitions of functional and objected oriented programming respectively.
% Are there multiple definitions? Motivate choice of definitions?

\textbf{Functional programming}

\begin{enumerate}
  \item All functions are \emph{pure}, meaning that they do not have any side-effects, and their output depends only on the input~\cite{john-m-chambers}. The latter is what Finifter et al. call \textit{determinism}, as mentioned in \autoref{sub:Verifiable-Functional-Purity-in-Java}~\cite{purity-in-java}.
    % We will go in more to this in \autoref{sub:Definition of functional purity}
\item Functions are first-class and can be higher-order, meaning that functions can be passed to functions as parameters, and can be returned by functions~\cite{jonas-walter}. % page 3
\item Variables are immutable, meaning that their value does not change after being initiated~\cite{jonas-walter}. % page 3
\end{enumerate}

\textbf{Object oriented programming} % Perhaps also mention imperative programming?

\begin{enumerate}
\item Computations are done via \emph{methods} belonging to \emph{objects}, whose structure suits the goal of whatever computation we're doing~\cite{john-m-chambers}.
\item Objects are based on \emph{classes}, and objects belonging to a class have a shared set of properties~\cite{john-m-chambers}.
\item Classes can \emph{inherit} from other superclasses, such that a class is also an instance of its superclass~\cite{john-m-chambers}.
\end{enumerate}

\noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}} % -------- Line break --------

\textbf{*Add a description of the following*}
\begin{itemize}
  \item Side-effects and referential transparency, which implies purity~\cite{purity-in-javascript}
  \item .NET Core/C\#
  \item Compilers
  \item Abstract syntax trees (ASTs)
  \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-syntax}{.NET ASTs}~\cite{albahari2003nutshell}
  \item Objects: fields and properties % https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members
\end{itemize}

Microsoft has an article on refactoring none-pure C\# code to pure functions \cite{microsoft-refactoring}.

\textbf{*Things to consider*}

\begin{itemize}
  \item Abstract syntax trees
  \item Input/output
  \item Recursion
  \item Monads
  \item Call-by-value vs. call-by-reference: % \textit{"For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed. This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object). Call-by-reference is not necessarily required for a function to modify a parameter."} - \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions}{link}.
  % \item Functions can be locally pure and/or globally pure https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions
  \item Control flow analysis
  % \item Could talk about Haskell in which all functions are pure and all values are immutable
  \item Sometimes we call compiled methods, i.e. methods that we don’t have the code for, e.g. the .NET framework base class library (BCL)
  \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/}{Delegates} and \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions}{anomynous functions}.
  \item Implicit and explicit variable declarations (C\# handles both)
  \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/identifier-names}{Identifiers} are the names of types, members variables or namespaces used in source code. They reference \href{https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-semantics#symbols}{symbols}, representing a declared namespace, type, method, field, variable, etc. The compiler's process of associating identifiers with symbols is called \textit{binding}~\cite{microsoft-semantic-analysis}. % TODO explain symbols and identifiers
  \item Closures and how objects can be considered closures (if fields are \texttt{readonly}?), and whether or not they should be considered pure.
  \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/}{Exceptions}.
\end{itemize}

% \subsection{The C\# Language} \label{sub:The C\# Language}
% TODO: short description of C\# and .NET

\subsection{Definition of functional purity} \label{sub:Definition of functional purity}
% Maybe move this before subsection to lead up to this?
As mentioned in \autoref{sec:Background}, the definition of functional programming consists of three parts. \textit{Purity}, functions being \textit{first-class} and \textit{higher-order}, and variables being \textit{immutable}. To delimit the scope of this thesis it will only focus on purity, mainly because it is the one which seems the most useful for object oriented programming, and as it is the one that is the most emphasized as a benefit of using a more functional style in object oriented programming~\cite{alvin-alexander}. % page 19

As seen in \autoref{sec:Related work} a lot of related work defines purity only as being synonymous with side-effect free. This definition therefore doesn't require functions' output to depend purely on their input -- what Finifter et al. call \textit{determinism}, as mentioned in \autoref{sub:Verifiable-Functional-Purity-in-Java} -- but allows them to read from variables defined outside of their scope. This definition is less functional. The definition of purity used in this thesis will therefore require pure functions to not only be side-effect free but also to be deterministic. This is the definition of purity that is used by Finifter et al.~\cite{purity-in-java}, Pitidis et al.~\cite{pitidis2010purity} and Alexander~\cite{alvin-alexander}, % page 19
the first two who's work is mentioned in \autoref{sub:Purity-in-Erlang} and \autoref{sub:Verifiable-Functional-Purity-in-Java}, respectively. Moreover, requiring pure functions to be both side-effect free \textit{and} deterministic does in a way also simplify the analysis because it means that any symbol used in a function \textit{F} but defined outside \textit{F} would make \textit{F} impure. If we allowed pure functions to be non-deterministic, that would mean that we would have to check each symbol used in \textit{F} to see if it is being written to or if it is only being read before concluding if \textit{F} is pure.

% The notion of purity only being synomynous with side-effect free seems to be more common in computer science, while also requireming determinism seems to be the more mathematical definition.

Thus, a function is pure if it is side-effect free and deterministic.

\subsection{What makes a C\# method pure?} \label{sub:What makes a Cs program functional?}
\autoref{fig:impure-example} and \autoref{fig:pure-example} illustrate two very simple examples of pure and impure code, respectively. In \autoref{fig:impure-example} the function \texttt{addOne()} is impure because it is writing to the variable \texttt{number} which was defined outside \texttt{addOne()}'s scope, which is a side-effect. \autoref{fig:pure-example} illustrates how \texttt{addOne()} can be rewritten to a pure function while preserving the program's semantics.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int number = 42;
    addOne();
    Console.WriteLine(number);

    void addOne()
    {
      number += 1; // this is a side-effect
    }
  \end{lstlisting}
  \caption{A simple example of \textit{impure} code due to a side-effect.}
  \label{fig:impure-example}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int number = 42;
    number = addOne(number);
    Console.WriteLine(number);

    int addOne(int num)
    {
      return num + 1;
    }
  \end{lstlisting}
  \caption{This is how \texttt{addOne()} from the example in \autoref{fig:impure-example} can be rewritten and used as a \textit{pure} function.}
  \label{fig:pure-example}
\end{figure}

Following are more technical requirements for C\# programs to be pure that are used as a basis for the implementation of the analysis tool. % maybe move to implementation?

% 1. Output depends only on input
% 2. No side-effects

\begin{itemize}
  \item Functions that modify any value outside their scope, e.g. a class variable or global variable, are impure. Modifying a value could be done by assigning a new value to it, or changing a part of it like modifying an element of a list or an object property.
  % Does this apply to all non-returning statements with no assignment, i.e. no '\texttt{=}' sign? Not if the data being modified through a method is inside the scope of the function.
  \item Functions that read any value outside the function's scope are impure. Reading a value could be done in many ways, including using it as argument in a function, as a condition in an \texttt{if}-statement, assigning it to a variable, etc. Basically any non-local variable appearing in a function would imply an impure read (except for if it is assigned to, which is mentioned above).
  % \item Functions that call other functions without reading the called function's return value are not pure?
  \item Functions that return \texttt{void} are assumed to be impure (because in order for them to have an effect on the program, they must have a side-effect).
  \item
  % By looking at the return statement of a function \textit{F} we could trace the variables and functions involved backwards in order to figure out \textit{F}'s purity. If all variables used in \textit{F}'s return statement are either input parameters or instantiated inside \textit{F}, \textit{F} is considered pure.
  This means that any variable read from or assigned to in a function \textit{F} must have been instantiated inside \textit{F} in order for \textit{F} to be pure.
  If any of \textit{F}'s parameters is an object, that object cannot be modified inside \textit{F} (at least not for the highest level of purity).
  \item Functions that call impure functions are themselves also impure.
  \item Functions that involve input/output (I/O) are impure.
\end{itemize}

Function parameters preceded with the \texttt{in} keyword are passed by reference and read-only inside the function~\cite{microsoft-in-modifier}. % This means that \texttt{in} parameters do not need to be checked (TODO: does this apply to data structures like lists?)
This means that input parameters marked with \texttt{in} cannot be re-assigned inside the function, which may suggest functional purity. Consider the example in \autoref{fig:in-example1}, where the parameter \texttt{number} is preceded by the \texttt{in} keyword. Because of this, modifying it inside the function will raise an error.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int globalValue = 42;
    addOne(globalValue);
    Console.WriteLine(globalValue); // value is still 42

    void addOne(in int number) // note the `in` keyword
    {
      number += 1; // illegal assignement will raise error CS8332
    }
  \end{lstlisting}
  \caption{Assignment to the parameter \texttt{number} which is preceded with \texttt{in} raises an error~\cite{microsoft-in-modifier}.}
  \label{fig:in-example1}
\end{figure}

However, \texttt{in} is note a purity guarantee. Consider the example in \autoref{fig:in-example2}. The \texttt{in} keyword before the argument \texttt{list} ensures that \texttt{list} is readonly. This prevents \texttt{list} from being re-assigned after instantiation, but it doesn't prevent the data structure which \texttt{list} refers to from being modified~\cite{buchanan-static-lists}. In C\# there are two kinds of types: \textit{value types} and \textit{reference types}~\cite{microsoft-types}. Value types directly contain their data, while reference types -- also known as objects -- are simply pointers that refer to the location of their data. The \texttt{in} keyword therefore only implies purity if applied to a variable of a value type. For the function to be pure all its parameters have to be value types and preceded with the \texttt{in} keyword. Even though strings are of the reference type they are immutable, meaning that they cannot be modified after being created~\cite{microsoft-strings}. Therefore the same thing that in this case applies to value types also applies to strings.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    List<int> globalValue = new List<int>{42};
    addOne(globalValue);
    globalValue.ForEach(Console.WriteLine); // list is now {42, 1}

    void addOne(in List<int> list) // note the `in` keyword
    {
      list.Add(1); // this will _not_ raise an error even though
                       // Add(1) modifies the list
    }
  \end{lstlisting}
  \caption{The expression \texttt{list.Add(1)} which writes a value to \texttt{list} is allowed, even though \texttt{list} is read-only due to its preceding \texttt{in} keyword.}
  \label{fig:in-example2}
\end{figure}

TODO

\subsection{The .NET Abstract Syntax Tree and the CodeAnalysis library} \label{The .NET Abstract Syntax Tree and the CodeAnalysis library}

In this thesis the term \textit{method} and \textit{function} will be used interchangeably.

% Abstract syntax trees in general
Abstract syntax trees (ASTs) are the primary data structure used when analysing source code~\cite{microsoft-work-with-syntax}. It encapsulates every piece of information held in the source code~\cite{microsoft-work-with-syntax}. A syntax tree generated by a parser can be be re-built into the exact same text that was originally parsed~\cite{microsoft-work-with-syntax}. TODO

The abstract syntax tree (AST) generated by the texttt{Microsoft.CodeAnalysis} library represents the lexical and syntactic structure of a .NET program~\cite{microsoft-work-with-syntax}. The tree consists primarily of \textit{syntax nodes} which represent syntactic constructs including declarations, statements, clauses and expressions~\cite{microsoft-work-with-syntax}. Each node is derived from the \texttt{Syntax}-\texttt{Node} class~\cite{microsoft-work-with-syntax}. Every node is non-terminal, meaning that they always have children - either other nodes or \textit{tokens}~\cite{microsoft-work-with-syntax}. Tokens are the smallest syntactic pieces of the program, consisting of keywords identifiers, literals and punctuation~\cite{microsoft-work-with-syntax}.

% An \textit{expression} consists of zero or more operators with one or more operands, which can be evaluated to a single value, method, object or namespace.
% https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expressions

\subsubsection{Microsoft Syntax Analysis API CodeAnalysis} \label{ssub:Microsoft Syntax Analysis API}
\texttt{Microsoft.CodeAnalysis} is a Syntax API developed by Microsoft which allows programmers to convert a C\# program to an abstract syntax tree and traverse it~\cite{microsoft-syntax-API}. TODO

\textbf{AST nodes}

\begin{itemize}
  \item The \texttt{ClassDeclarationSyntax} node represents the declaration of a class.
  \item The \texttt{MethodDeclarationSyntax} node represents the declaration of a meth-od. Each \texttt{MethodDeclarationSyntax} node has a \texttt{ParameterListSyn}- \texttt{tax} - a list of \texttt{ParameterSyntax} nodes represents, each representing a me-thod parameter.
  \item The \texttt{LocalFunctionStatementSyntax} node represents a function decla-red inside a method. Just like the \texttt{MethodDeclarationSyntax} it has a \texttt{Param}-\texttt{eterListSyntax} representing the local function's parameters.
  \item The \texttt{ReturnStatementSyntax} node represents the \texttt{return} token.
  \item The \texttt{VariableDeclarationSyntax} node represents declarations of new variables.
  \item The \texttt{LocalDeclarationStatementSyntax} node represents declarations of new local variables. This node contains a \texttt{VariableDeclarationSyntax} node.
  \item The \texttt{AssignmentExpressionSyntax} node represents assignments to already instantiated variables.
  \item The \texttt{IdentifierNameSyntax} node represents symbols used in the code, including variable names and method names.
\end{itemize}

\subsection{C\# Events} \label{sub:Events}
Events are a way for classes or object to notify other classes or objects when something happens~\cite{microsoft-events}. The class raising the event is called the \textit{publisher} and the class handling the event is called the \textit{subscriber} (there can be more than one subscriber)~\cite{microsoft-events}. When an event is raised the subscriber's handler method is executed. Since events clearly are side-effects, a method that raises events is not considered pure

\subsection{Problems with determining purity in object oriented languages} \label{sub:Problems with determining purity in object oriented languages}

\subsubsection{Inheritance and method overriding} \label{sub:inheritance}

When calling an object parameter's method, because of inheritance and method overriding we can never be sure of which method implementation will be called. Consider the following example~\cite{pearce2011jpure}:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    void f(List<string> x) {
      x.Add("Hello");
    }
  \end{lstlisting}
  \caption{Since \texttt{x} can be of any subclass of \texttt{List} we can never be sure of \texttt{x.Add()}'s implementation.}
  \label{fig:inheritance-example}
\end{figure}

Because the parameter \texttt{x} can be of any subclass of \texttt{List} we can not for sure know the implementation of \texttt{x.Add()}, nor therefore can we be certain of \texttt{x.Add()}'s purity. Thus, we can not determine \texttt{f()}'s purity.

One solution to this that David J. Pearce suggests is to demand that pure methods only are overridden by methods that are also pure~\cite{pearce2011jpure}. Therefore, if a method \textit{m} is overridden by at least one impure method, \textit{m} is assumed to be impure.

This means that in the example in \autoref{fig:inheritance-example}, the function \texttt{f()} is pure iff all methods that override \texttt{List.Add()} are pure.

\subsubsection{Modifying a fresh object} \label{sub:modifying-fresh-objects}

If an object \textit{o} is allocated inside the analysed method \textit{m}, the object \textit{o} is said to be \textit{fresh}~\cite{pearce2011jpure}. To modify \textit{o}'s state we might call a method that looks impure (since that method would have the side-effect of modifying \textit{o}). However, this method should not make \textit{m} impure since \textit{o} is fresh, which means that the modification of \textit{o} is not a side-effect of \textit{m}.

Consider the following example:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public List<String> Foo() {
      List<String> list = new List<String>();
      list.Add("hello"); // this changes list's state
      return list;
    }
  \end{lstlisting}
  \caption{TODO}
  \label{fig:fresh-object-example}
\end{figure}

Because \texttt{list.Add()} in \autoref{fig:fresh-object-example} modifies the state of \texttt{list}, which is a side-effect, \texttt{Add()} cannot be a pure method. Does that mean that since the function \texttt{Foo()} calling \texttt{list.Add()} is impure, because it calls a non-pure method? In general functions that invoce impure functions are themselves impure. However, this is not the case for \texttt{Foo()}. Recall the definition of purity in \autoref{sub:Definition of functional purity}:

\textit{A function is pure if it is side-effect free and deterministic}.

Because the function \texttt{Foo()} only modifies an object exclusively visible inside the function, \texttt{Foo()} does not have any side-effect. Nor is the function non-deterministic since it does not read any value outside of the function besides its parameters, which it in this case doesn't have. This means that \texttt{Foo()} is pure.

To solve this we introduce the purity level \textit{locally impure}. Any method that is pure except for reading or modifying its object's fields is locally impure. This includes methods that return \texttt{this} or pass \texttt{this} as an argument to a function. Consider the following:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public A Foo() { // pure
      A a = new A();
      a.Increment();
      return a;
    }

    public class A {
      public int value = 0;

      public void Increment() { // locally impure
        value++;
      }
    }
  \end{lstlisting}
  \caption{Since \texttt{Foo()} modifies a fresh object with a locally impure method \texttt{Foo()} is still pure.}
  \label{fig:locally-impure-example}
\end{figure}

The method \texttt{Increment()} in \autoref{fig:locally-impure-example} is locally impure because it modifies its object's field \texttt{value} but doesn't have any other side-effects. A function that calls a locally impure method on a fresh object is not contaminated by its local impurity.

There is however one more way to modify a fresh object: to pass it as an argument to a method that alters its state. Consider the following example:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public A Foo() { // pure
      A a = new A();
      A.Increment(a);
      return a;
    }

    public class A {
      public int value = 0;

      public static void Increment(A a) { // parametrically impure
        a.value++;
      }
    }
  \end{lstlisting}
  \caption{Since \texttt{Foo()} modifies a fresh object with a parametrically impure method \texttt{Foo()} is still pure.}
  \label{fig:parametrically-impure-example}
\end{figure}

Because the method \texttt{Increment()} in \autoref{fig:parametrically-impure-example} modifies its input parameter object it cannot be considered truly pure. However, since \texttt{Foo()} uses \texttt{Increment()} to modify a fresh object \texttt{Foo()} is still pure. I have chosen to categorize methods that are pure except for modifying the state of its input as \textit{parametrically impure}. There are two ways for a method to modify its input parameters: either by mutating a value belonging to a reference type input parameter, i.e. an object's field or property, or the cell of an array; or by calling a locally impure method belonging to a parameter object.

The key thing in both the example where a method \textit{m} calls locally and parametrically impure methods is that they modify a fresh object, which therefore doesn't affect \textit{m}'s purity level. So as long as the analyzed method \textit{m} or any of its called methods don't perform any truly impure action like I/O operations or throw exceptions, \textit{m} is pure.

What if a an object's method is both locally and parametrically impure? Just like in the previous cases, as long as the object is fresh the purity of the callee is not affected.

\subsubsection{Iterators}

% This part is probably not relevant because my definition of purity includes determinism. Do I mention this or just delete this part? -- mention it

As Pearce suggests, an iterator may at first glance look pure~\cite{pearce2011jpure}. Consider the following (\href{https://docs.microsoft.com/en-us/archive/msdn-magazine/2017/april/essential-net-understanding-csharp-foreach-internals-and-custom-iterators-with-yield}{link}):

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    bool ListHas(List<int> items, int item) {
        foreach(int i in items) if(i == item)  return true;
        return false;
    }
  \end{lstlisting}
  \caption{\texttt{ListHas()} may at first glance look pure}
  \label{fig:iterator-example}
\end{figure}

TODO: explain that this doesn't affect us because our definition of purity includes determinism

\subsubsection{Non-static property pointing to a static field} \label{ssub:non-static-property}
\textit{Properties} in C\# are special \texttt{get} and \texttt{set} methods for reading, computing or writing to values of object fields~\cite{microsoft-properties}. Properties can, just like other fields or methods be set to \texttt{static}, which means that they are assigned to the class rather than any instantiated object. If a method reads from or modifies a static property, that method would be considered to be non-determinsitc or to have a side-effect, i.e. it would be impure, because static fields are accessible anywhere in a program.

However, properties can also be non-static but still read or modify static fields. Consider the following:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public class Foo {
      public Swede gert = new Swede();

      public void Bar() {
        Swede stina = new Swede();
        stina.Nationality = "Norway"; // assignment to non-static field

        Console.WriteLine(gert.Nationality); // prints "Norway"
      }

      public class Swede {
        static string nationality = "Sweden"; // This field is static

        public string Nationality { // This property is non-static
          get { return nationality; }
          set { nationality = value; }
        }
      }
    }
  \end{lstlisting}
  \caption{What looks like a non-static assignment to an object property does in fact mutate a static field, which is a clear side-effect of \texttt{Bar()}}
  \label{fig:non-static-property-example}
\end{figure}

In the example in \autoref{fig:non-static-property-example}, the method \texttt{Bar()} assigns to the field \texttt{Nationality} of the fresh object \texttt{stina}. Because the property \texttt{Nationality} is non-static it, it might look like a pure action at a first glance. But since the property writes method \texttt{get} itself modifies a static field, the \texttt{Bar()}'s assignment to \texttt{Nationality} is in fact a side-effect, which alterse all \texttt{Swede} objects' \texttt{Nationality}. Therefore, it is not enough to check if a property is static in order to determine whether a read or write is pure, but the property's \texttt{get} and \texttt{set} have to be checked as well.

*Perhaps ignore cases like this for simplicity?*

\subsection{The analysis} \label{sub:Analysis}
\begin{itemize}
  \item There are five kinds of purity levels: \textit{pure}, \textit{locally impure}, \textit{parametrically impure}, \textit{impure}, and \textit{unknown}.
  \item Traverse the Abstract Syntax Tree (AST) and build the \textit{dependency set} of each function, i.e. the set of calls inside the function.
    Because of the problem with inheritance and method overriding discussed in \autoref{sub:inheritance}, when calling a an object parameter's method $m_p$ we cannot know which method implementation will be called if the parameter type has subclasses that override $m_p$. Therefore when going through the AST and building the dependency set, if such an overriden parameter method is encountered, add all the overridden methods to the calling function's dependency set.
    Each function together with its dependency set is stored in a lookup table where the key is the function identifier \textit{f} and the values are \textit{f}'s dependency set $D_f$ as well as \textit{f}'s purity level \textit{p}. % For each function analyzed, add the identifier of any modified object field or property ... TODO

    Function identifier (\textit{f}):
    \begin{itemize}
      \item \textit{f}'s dependency set $D_f$
      \item Fields or properties read by \textit{f}
      \item Fields or properties assigned to by \textit{f}
      \item \textit{f}'s purity level \textit{p}
    \end{itemize}

    After constructing the lookup table, start by analyzing the functions with empty dependency sets $D_f$... TODO

  \item If any object field or property of the currently analyzed method \textit{m}'s object is read from or modified, mark \textit{m} as locally impure.
  \item If the currently analyzed method \textit{m} calls an input parameter's method $m_p$ and $m_p$ is overridden by any impure, locally impure and/or parametrically impure method, mark $m_p$ with the impurity or impurities of the overriding method or methods. % Moreover:
    % \begin{itemize} % Maybe these are covered by other cases?
    %   \item If $m_p$ is overridden by any impure method, \textit{m} is marked impure.
    %   \item If $m_p$ is overridden by any locally impure method, \textit{m} is marked parametrically impure.
    % \end{itemize}
  \item If the analyzed method \textit{m} modifies an input parameter of reference type, mark \textit{m} as parametrically impure. This could be done in a couple of ways:
    \begin{itemize}
      \item By directly mutating a parameter object's field or property, or the cell of a parameter array.
      \item By calling an object type parameter's method that has been marked locally impure, i.e. the called method may have been overridden by a locally impure method as mentioned previously.
      \item By passing a parameter as an argument to a parametrically impure method.
    \end{itemize}
    If \textit{m} does at least one of the above, mark it as parametrically impure.
  \item If a method returns \texttt{this} or passes it as an argument to a function it should be considered locally impure since it is dependent on the state of its object, making it non-deterministic.
  \item Any method that raises an event or an exception is marked as \textit{impure}.
  % \item Build a lookup table with all evaluated functions, their purity and their dependency set~\cite{pitidis2010purity}.
  \item If the analysis finds a call or reference to a compiled method or a field, or any other method that we cannot determine the purity of, mark its purity as \textit{unknown}.
  \item If the method \textit{m} calls a locally impure method belonging to the same object as \textit{m} (i.e. \texttt{this}) \textit{m} is also impure
  \item If the method \textit{m} reads or modifies a static field of an object, \textit{m} is marked impure. This is because reading a static field of an object is a non-deterministic action, and modifying a static field of an object is a side-effect since it mutates the field for all instantiations of that object's class. % TODO: reading a or modifying a non-static property which points to a static field.
\end{itemize}

If a called method \textit{m} is locally impure, only mark \textit{m}'s callee \textit{M} as impure if the object which \textit{m} belongs to was not created inside the callee \textit{M}. %  This means that if \textit{m}

*Do we even have check if objects are fresh? If they aren't, then we've read from a field outside the method, i.e. \textit{m} is non-deterministic i.e. locally impure.*

A method \textit{m} that calls a locally impure method of an object is not marked impure if the object was fresh, i.e. created by \textit{m}.

\subsection{Code base} \label{sub:Code base}
\textbf{Mostly pure code}
\begin{itemize}
  \item \href{https://github.com/dotnet/roslyn/blob/master/src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/Utilities/CompilerUtilities/ImmutableHashMap.cs}{\texttt{ImmutableHashMap.cs}} - has many methods marked with \texttt{[pure]}
  \item \href{https://github.com/nodatime/nodatime/blob/master/src/NodaTime}{NodaTime} has many pure methods. NodaTime's \href{https://github.com/nodatime/nodatime/blob/master/src/NodaTime/AnnualDate.cs}{\texttt{AnnualDate.cs}} for instance has many pure methods not marked with \texttt{[pure]}
\end{itemize}

\textbf{Mostly impure code}
\begin{itemize}
  \item \href{https://github.com/SixLabors/ImageSharp/blob/master/src/ImageSharp}{ImageSharp}
  \item \href{https://github.com/geaz/sharpDox}{sharpDox}
\end{itemize}

\section{Implementation of the analysis tool} \label{sec:Implementation of the analysis tool}
% \item For performance reasons, first check general stuff and then do more specific checks.

% Because of the poor documentation of the \texttt{CodeAnalysis} library, a lot of time was spent on playing around with it and figuring out how it is intended to be used.

Because there was a clear goal for the software and it's requirements, test driven development was used.

Because .NET has many libraries with functions of unknown purity, the purity level "unknown" has to be added.

The code analysis tool is built in .NET core and C\#. It can be compiled, run and tested from the command line using the command \href{https://docs.microsoft.com/en-us/dotnet/core/tools/}{\texttt{dotnet}}, followed by \texttt{run}, \texttt{build} or \texttt{test}, respectively.

To find the declaration/definition of symbols (in the form of \texttt{IdentifierNameSyn\allowbreak tax}) the method \texttt{SemanticModel.GetSym\allowbreak bolInfo()} is used, which uses the semantic model of the program.

% A very simple implementation could be one that only looks at input parameters and checks if they are all

TODO

\section{Results} \label{sec:Results}
Static method purity is calculated as the percentage of all methodsin the call graph that are pure~\cite{xu2007dynamic}.
TODO

\section{Related work} \label{sec:Related work} % (If not part of introduction)

\subsection{Purity in Erlang} \label{sub:Purity-in-Erlang}
In their paper \textit{Purity in Erlang} Mihalis Pitidis and Konstantinos Sagonas develop a tool that automatically and statically analyses the purity of Erlang functions~\cite{pitidis2010purity}. It classifies functions into being functionally pure, or one of three levels of functional impurity~\cite{pitidis2010purity}.
The three levels of functional impurity they defined are: containing side-effects; containing no side-effects but being dependent on the environment; and containing no side-effects, having no dependencies on the environment but raising exceptions~\cite{pitidis2010purity}.

Their definition of purity uses \textit{referential transparency}, as it implies purity~\cite{pitidis2010purity}. Referential transparency means that an expression always produces the same value when transparency~\cite{pitidis2010purity}. This means that a referentially transparent function could always be replaced with it's output without altering the program's behaviour in any way~\cite{pitidis2010purity}.

They store all analysis information in a \textit{lookup table} where the keys are the function identifiers \textit{f} and the values are the purity level \textit{$p_f$} of each \textit{f} as well as \textit{f}'s \textit{dependency set} $D_f$~\cite{pitidis2010purity}. The dependency set is the set of functions being called by \textit{f} and is constructed by parsing the program's Abstract Syntax Tree~\cite{pitidis2010purity}.

Their analysis starts with Erlang's so called built in-functions (BIFs), which are functions native to the Erlang's virtual machine and are written in C~\cite{pitidis2010purity}. Impure actions in Erlang can only be done through BIFs, including performing I/O actions or writing to global variables~\cite{kostis-email}. Because BIFs are written in C they cannot be analysed by their analysis tool, and their purity is assumed to be already known in beforehand by the analysis tool~\cite{pitidis2010purity}. The analysis propagates the impurity of BIFs to each function which directly or indirectly depends on them.

In short terms, their analysis algorithm works like this: Initialize the purity of all functions in the lookup table to be analyzed to "pure"~\cite{pitidis2010purity}. Define the \textit{working set} to always equal the set of functions whose purity level is fully determined, i.e. the functions with empty dependency sets~\cite{pitidis2010purity}. For each function \textit{f} in the working set, propagate its purity level to functions depending on it and "contaminate" them with \textit{f}'s purity level~\cite{pitidis2010purity}. Then remove \textit{f} from the  dependency set of each function depending on it~\cite{pitidis2010purity}. If \textit{f} has the highest impurity level, remove the entire dependency set of each function depending on \textit{f}~\cite{pitidis2010purity}. If the working set gets empty, find a set of functions that are dependent on each other and no other functions, and set their purity level to the purity of the impurest function~\cite{pitidis2010purity}. Simplify their dependency sets by removing their dependency on each other from their dependency set~\cite{pitidis2010purity}. Repeat this process until there are no more changes to the lookup table~\cite{pitidis2010purity}.

TODO

% By parsing the Abstract Syntax Tree of the code they construct a \textit{dependency set} for each function \textit{f}, i.e. the set of functions being called by \textit{f} ... TODO (page 5 in \cite{pitidis2010purity}).

\subsection{JPure: A Modular Purity System for Java} \label{sub:JPure: A Modular Purity System for Java}
David J. Pearce built a purity system and analyzer for Java in his paper JPure: a modular purity system for Java~\cite{pearce2011jpure}. The system uses the properties \textit{freshness} and \textit{locality} to increase the the system's ability to classify methods as pure~\cite{pearce2011jpure}. An object is fresh if it is newly allocated inside a method~\cite{pearce2011jpure}. An object's locality is its local state~\cite{pearce2011jpure}. Their definition of a pure method is one that does not assign (directly or indirectly) to any field that exisetd before the method was called~\cite{pearce2011jpure}.

The system uses uses annotations \texttt{@Pure}, \texttt{@Local}, \texttt{@Fresh}. \texttt{@Pure} indicates that a method is pure. \texttt{@Local} indicates that a method only modifies an object's locality. \texttt{@Fresh} indicates that a method only returns fresh objects. These three annotations are modularly checkable, i.e. one method's purity annotations to be checked in isolation from all other methods.

The system consists of two parts, \textit{purity inference} and \textit{purity checker}~\cite{pearce2011jpure}. Purity inference adds \texttt{@Pure} annotations (and any auxiliary annotations required) to the code and is intended to be run once because it is more costly. The purity checker checks the correctness of all annotations at compile-time, and is intended to be used continuously to maintain the code's purity.

TODO

\subsection{Purity and Side Effect Analysis for Java Programs} \label{sub:Purity and Side Effect Analysis for Java Programs}
Similarly, S\u{a}lcianu and Rinard presented a method for analysing purity in Java programs, but their definition of purity also only includes side-effects and does not look at the input or output~\cite{salcianu}. Their pointer analysis is based on tracking object creation and updates, as well as updates to local variables, and defines methods that mutate memory locations that existed before a method call as impure~\cite{salcianu}. Moreover, their analysis can recognize purity-related properties for impure methods, including \textit{read-only} and \textit{safe} parameters~\cite{salcianu}.

The analysis method presented looks at each program point in each method \textit{m}, and computes a points-to graph modelling the parts of the heap that method \textit{m} points to, represented by nodes in the graph~\cite{salcianu}. There are three kinds of nodes: \textit{Inside nodes} which model objects created by \textit{m}, \textit{parameter nodes} which model objects passed to \textit{m} as arguments, and \textit{load nodes} modelling objects read from outside \textit{m}~\cite{salcianu}. Edges in the points-to graph model heap references~\cite{salcianu}. There are two types of edges: \textit{inside edges} which model heap references created by \textit{m}, and \textit{outside edges} modelling heap references read by \textit{m} from outside of it (this includes \textit{m}'s parameters)~\cite{salcianu}.

% For each method \textit{m} the analysis computes a set $W_m$ containing the mutated fields that are externally visible.

The analysis also keeps track of \textit{globally escaped nodes}, which are nodes that may be accessed by unknown code, i.e. passed as argument to a native methods or pointed to static fields~\cite{salcianu}. Since globally escaped nodes may be mutated by unknown code, the analysis has to handle them conservatively~\cite{salcianu}.

To check if a method \textit{m} is pure, the analysis computes the set \textit{A} consisting of nodes reachable from parameter nodes along outside edges~\cite{salcianu}. In other words, \textit{A} represents all objects existing before executing \textit{m}~\cite{salcianu}. \textit{m} is pure if and only if no node in \textit{A} escapes globally (i.e. is accessed by unknown code) and no fields in any node in \textit{A} is modified~\cite{salcianu}. There is one exception to the purity constraint: constructors are allowed to mutate fields of the \texttt{this} object~\cite{salcianu}. Therefore all mutated abstract fields of \texttt{this} are ignored by the analysis~\cite{salcianu}.

TODO

\subsection{Detecting function purity in JavaScript}
% This was a little too difficult to understand, maybe remove from related work?
Nicolay et al. developed a method of detecting function purity in JavaScript using something called \textit{pushdown analysis}~\cite{purity-in-javascript}. Their definition of functional purity, however, includes only side-effects and does not require functions' output to depend purely on their input~\cite{purity-in-javascript}.

% Because everything except for

\subsection{Writing Pure Code in C\#} \label{sub:Writing Pure Code in Cs}
In his article \textit{Writing Pure Code in C\#} Massad defines three levels of pure methods~\cite{yacoub-massad-pure-code}:
\begin{enumerate}
  \item Pure methods, i.e. methods that do not read or write to instance state variables, or call impure methods.
  \item Methods that are pure, and that \textit{read} the state of their containing object, or the state of objects that are passed as parameters or created in the current method.
  \item Methods that are pure, and that \textit{read} or \textit{write} to the state of their containing objects, or to the state of objects created in the current method.
\end{enumerate}

\subsection{.NET Code Contracts} \label{sub:Code contracts} % kanske ta bort eller flytta till Backgrounds?
.NET code contracts are used to define pre- and postconditions, as well invariants for pieces of code -- some which can be checked statically and some at runtime~\cite{microsoft-code-contracts}. One available code contract is the \texttt{[pure]} attribute, which indicates that the method is pure~\cite{microsoft-code-contracts}. However, current analysis tools do not enforce that methods marked with \texttt{[pure]} actually are pure, and so the attribute does not guarantee functional purity. Microsoft defines pure methods as methods that don't modify an pre-existing state, i.e. methods can only modify objects that were created \textit{after} the method was called. The following code elements are assumed by the code contract tools to be pure~\cite{microsoft-code-contracts}:

\begin{itemize}
  \item Methods or types marked with \texttt{[pure]} (for types marked with \texttt{[pure]} this should apply to to all the type's methods).
  \item Property get accessors.
  \item Operators.
  \item Any method with a fully qualified name starting with \texttt{System.Diagnost\-ics.Contracts.Contract}, \texttt{System.String}, \texttt{System\-.IO.Path}, or \texttt{System.Type}.
  \item Any called delegate with the \texttt{[pure]} attribute. Delegates are basically function pointers.
\end{itemize}

\subsection{Evolution of Degree of Purity in Programming Languages} \label{sub:Evolution of Degree of Purity in Programming Languages}
Rajasekhara Babu et al.~\cite{rajasekharababu2012evolution}.

\subsection{Verifiable Functional Purity in Java} \label{sub:Verifiable-Functional-Purity-in-Java}
In their definition of functional purity Finifter et al. require pure functions to be both side-effect free and \textit{deterministic}~\cite{purity-in-java}. A function is deterministic if any two evaluations of it have the same result~\cite{purity-in-java}. This means that a deterministic function is one that relies purely on its arguments~\cite{purity-in-java}. A function is side-effect free if it only modifies objects that were created during its execution~\cite{purity-in-java}.

The language that their analyzer handles is a subset of Java, in which they can prove functional purity~\cite{purity-in-java}. They make the point that if all of method's parameters are immutable, including the implicit \texttt{this}, then the method is pure~\cite{purity-in-java}. % page 166
If its class is immutable it means that a method's global scope has a constant state, and so the only varying state is the one observable through its arguments~\cite{purity-in-java}.

Their verifier has a white list of fields and methods from Java libraries that do not expose the ability to observe a global mutable state, or provide access to nondeterminism, and it will reject any reference to a field or method that is not on the list~\cite{purity-in-java}.

\subsection{Dynamic Purity Analysis For Java Programs} \label{sub:Dynamic Purity Analysis For Java Programs}
TODO

\section{Future Work and Conclusion} \label{sec:Conclusion and future Work}
\subsection{Future work} \label{sub:Future work}

\begin{itemize}
  \item Tool can point out exact position of impurity and suggest improvements to increase the purity.
\end{itemize}

\subsection{Conclusion} \label{sub:Conclusion}
\textit{Functional purity} is perhaps the most useful concept from functional programming that object oriented programmers can learn from. The definition of a pure program used in this paper is one that is side-effect free and determinstic.

\bibliography{references}

%\appendix % markerar att resten är appendix

\end{document}
