% Template taken from https://github.com/independent-project-in-it-uu-2019/rapport-mall/blob/master/rapport-mall.tex

% MUST use a4paper option
% MAY use twoside, smaller font, and other class
\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc} % Use UTF-8 encoding in input files
% NOTE: If you are writing in English, un-comment the following line:
\usepackage[swedish,english]{babel}
\usepackage{UppsalaExjobb} % Use the template for thesis reports

\usepackage{amssymb,amsmath,amsthm,amsfonts} % Useful font packages for maths and symbols
\usepackage{listings} % for nice code listings
\usepackage{placeins}
\usepackage{pdfpages}
\usepackage{float}
\usepackage{hyperref}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=cyan,
}
\urlstyle{same}

% styling of code
% \definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{%frame=tb,
  language=java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  basicstyle={\fontsize{10}{11}\ttfamily},
% numbers=left,
% numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=false,
  tabsize=2,
  morekeywords={}
}

% Use one of these:
% - IEEEtranS gives numbered references like [42] sorted by author,
% - IEEEtranSA gives ``alpha''-style references like [Lam81] (also sorted by author)
% \bibliographystyle{IEEEtranSA}
\bibliographystyle{IEEEtranS}
\bstctlcite{IEEEexample:BSTcontrol}
%\bibliographystyle{plainurl}

% Designval: per default används styckesindrag, men ibland blir det snyggare/mer lättläst med tomrad mellan stycken. Det åstadkoms av de följande raderna.
% Tycker ni om styckesindrag mera, kommentera bort nästa två rader.
\parskip=0.8em
\parindent=0mm
% Designval: vill ni ha en box runt figurer istället för strecken som är default, av-kommentera raden nedan. Obs att både \floatstyle och \restylefloat behövs.
\floatstyle{boxed} \restylefloat{figure}
% \floatstyle{plain} \restylefloat{figure}

\newtheorem{definition}{Definition} % Adds the \begin{definition}...
\newcommand*{\definitionautorefname}{definition} % Allows autoref to definition

\begin{document}
% Set title, and subtitle if you have one
% \title{To what extent is C\# being used as a functional programming language?}
\title{To what extent is functional purity being used in C\# open source programs?}
% Use this if you have a subtitle
% \subtitle{An evaluation of functional purity in C\#}
\subtitle{A methodology for measuring functional purity in C\#}
% Set author names, separated by "\\ " (don't forget the space)
% List authors alphabetically by last name (unless someone did significantly more/less)
\author{Melker Österberg}

% Set the date and year - use the right language!
\date{
  \begin{otherlanguage}{English}  %\foreignlanguage doesn't seem to affect \today?
    \today
  \end{otherlanguage}
}

% Only need to set the year if it differs from the current year
%\year=2018
\handledare{Mikael Axelsson, Erik Löthman}
\reviewer{Konstantinos Sagonas}

% Programnamn på svenska och engelska
\progname{Civilingenjörsprogrammet i Informationsteknologi}{Master Programme in Computer and Information Engineering}

% Utgivare
\enhetsnamn{Institutionen för \\ Informationsteknologi}
%\enhetsnamn{Department of Information Technology}
\besoksadress{ITC, Polacksbacken\\ Lägerhyddsvägen 2}
\postadress{Box 337 \\ 751 05 Uppsala}
\hemsida{http:/www.it.uu.se}

% Set the name of the series, and the number in the series
\seriesname{Master Thesis}
%\seriesname{Independent Project in Information Engineering}
% \seriesname{Uppsatsmetodik}

% OBS: Gäller bara exjobb i årskurs 5
% Get a series number, e.g. from Studentservice Ångström
%\seriesnumber{}
% Use the appropriate ISSN for the series
%\issn{}
% Usually this is where it is printed
%\printer{}

% This creates the title page
\maketitle

% Change to frontmatter style (e.g. roman page numbers)
\frontmatter

\begin{abstract}
This thesis develops a method of statically determining the level of purity in a given C\# program. It investigates problems with determining purity in object oriented languages, with a focus on C\#. A function is defined to be pure if it side-effect free and deterministic.

TODO
\end{abstract}

\begin{sammanfattning}
  TODO
\end{sammanfattning}

% Innehållsförteckningen här.
\tableofcontents

% Här kan man också ha \listoffigures, \listoftables

\cleardoublepage

% Change to main matter style (arabic page numbers, reset page numbers)
\mainmatter

\section{Introduction} \label{sec:Introduction}
% https://dl-acm-org.ezproxy.its.uu.se/doi/pdf/10.1145/1455770.1455793?download=true (\cite{purity-in-java}) has motivation for using pure functions in its abstract

Functional programming is on the rise and becoming more mainstream~\cite{intertech}. Object oriented (OO) programming has been the industry norm for quite some time now, and for a long time functional programming was considered by developers to only be applicable in academic domains. However it is now becoming popular in the IT industry as well. Many mainstream languages like Java, C\# and C++ have adopted first-class functions from the functional paradigm~\cite{intertech}. Moreover, functional programming can be used for building web applications and mobile apps~\cite{jonas-walter}.

Functional programs have many benefits over purely object oriented ones. Perhaps one of the most useful features of functional programming that the object oriented world of programming could adopt is \textit{functional purity}. Programs with pure functions are generally easier to reason about impure ones because they have no \textit{side-effects}~\cite{alvin-alexander}. A side-effect is anything that a function does besides producing a return value and that is visible from the function's caller's point of view~\cite{purity-in-javascript}. Pure functions are also easier to test since all we need to look at are functions' inputs and outputs, which also, for instance, facilitates property-based testing~\cite{alvin-alexander}. Moreover, research has shown that pure programs are easier to debug and maintain~\cite{purity-in-javascript}. % page 1
For this reason it useful in software engineering to evaluate the level of functional purity in programs~\cite{purity-in-javascript}.

C\# is among the top five most popular programming languages~\cite{tiobe}. To its core, it is an object-oriented programming language. However, it has features that allow for functional programming~\cite{hamid-mosalla}. But to what extent is C\# being used as a functional programming language by developers? This paper will attempt to answer this by evaluating to what degree functional purity is used in C\# programs today.

% Yannis Smaragdakis and Brian McNamara showed that there are ways of converting the common OO design patterns Command, Observer, Adaptor, Visitor and Virtual Proxy in C++ to functional programs using FC++ -- a library that adds many functional features to C++~\cite{yannis-smaragdakis}. Would this kind of transformation be useful for programs written in C\#? If C\# is not currently being used primarily as a functional programming language, this tool could be useful to programmers that want to refactor an existing OO program to a functional one.

% \subsection{Contricutions} \label{sub:Contricutions}

\section{Definitions} \label{sub:definitions}
Functional programming and object oriented programming are two different programming paradigms. There is no universal definition of either of them. Following is how they have been chosen to be defined in this thesis.

\subsection{Object oriented programming} \label{ssub:object-oriented-programming} % Perhaps also mention imperative programming?

\begin{enumerate}
\item Computations are done via \textit{methods} belonging to \textit{objects}, whose structure suits the goal of whatever computation we're doing~\cite{john-m-chambers}.
\item Each object has a unique \textit{object identity} which distinguishes it from all other objects~\cite{khoshafian1986object}.
\item Objects are based on \emph{classes}, and objects belonging to a class have a shared set of properties~\cite{john-m-chambers}.
\item Classes can \emph{inherit} from other superclasses, such that an object of a class is also an object of its superclass~\cite{john-m-chambers}.
\end{enumerate}

\subsection{Functional programming} \label{sub:functional-programming}

\begin{enumerate}
  \item All functions are \emph{functionally pure}. Functional purity is defined below in \autoref{ssub:functional-purity-definition}.
  \item Functions are first-class and can be higher-order, meaning that functions can be passed to functions as parameters, and can be returned by functions~\cite{jonas-walter}. % page 3
  \item Variables are immutable, meaning that their value does not change after being initiated~\cite{jonas-walter}. % page 3
\end{enumerate}

% As mentioned in \autoref{sub:functional-programming}, the definition of functional programming consists of three parts. \textit{Purity}, functions being \textit{first-class} and \textit{higher-order}, and variables being \textit{immutable}.
To delimit the scope of this thesis it will only focus on functional purity, mainly because it seems like the most useful one out of the three for object oriented programming.% , and as it is the one that is the most emphasized as a benefit of using a more functional style in object oriented programming~\cite{alvin-alexander}. % page 19

\subsection{Definition of functional purity} \label{ssub:functional-purity-definition}
% Maybe move this before subsection to lead up to this?

Following is the definition of functional purity that will be used in this thesis:

\begin{definition}[Functional purity] \label{def:functional-purity}
  A function is functionally pure if it is \textit{side-effect} free and \textit{deterministic}.
\end{definition}

\textit{Side-effect} and \textit{determinism} are defined as follows:

\begin{definition}[Side-effect] \label{def:side-effect}
  A side-effect is any action performed by a function that is visible from the function's caller's point of view~\cite{purity-in-javascript}.
\end{definition}

\begin{definition}[Determinism] \label{def:determinism}
  A function is deterministic if its output depends purely on its input parameters, i.e. the method must return the same value for the same input regardless of the state of the program~\cite{purity-in-java}.
\end{definition}

As seen in \autoref{sec:Related work} some related work define functional purity only as being synonymous with "side-effect free". This definition omits determinism and allows functions to read from variables defined outside of their scope, which is less functional. The definition of purity used in this thesis will therefore require pure functions to not only be side-effect free but also to be deterministic. This is the definition of purity that is used by Finifter et al.~\cite{purity-in-java}, Pitidis et al.~\cite{pitidis2010purity} and Alexander~\cite{alvin-alexander}. % page 19
% the first two who's work is mentioned in \autoref{sub:Purity-in-Erlang} and \autoref{sub:Verifiable-Functional-Purity-in-Java}, respectively.
Moreover, requiring pure functions to be both side-effect free \textit{and} deterministic does in a way also simplify the analysis because it means that any symbol used in a function \textit{F} but defined outside \textit{F} would make \textit{F} impure. If we allowed pure functions to be non-deterministic, that would mean that we would have to check each symbol used in \textit{F} to see if it is being written to or if it is only being read before concluding if \textit{F} is pure.

% The notion of purity only being synomynous with side-effect free seems to be more common in computer science, while also requireing determinism seems to be the more mathematical definition.

% \noindent\makebox[\linewidth]{\rule{\textwidth}{0.4pt}} % -------- Line break --------

% \textbf{*Add a description of the following*}
% \begin{itemize}
%   \item Side-effects and referential transparency, which implies purity~\cite{purity-in-javascript}
%   \item Objects: fields and properties % https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/members
%   \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/}{Exceptions}.
% \end{itemize}

% % Microsoft has an article on refactoring none-pure C\# code to pure functions \cite{microsoft-refactoring}.

% \textbf{*Things to consider*}

% \begin{itemize}
%   \item Input/output
%   \item Monads
%   \item Call-by-value vs. call-by-reference: % \textit{"For reference types, if you pass a parameter by value, it results in a copy of the reference to an object being passed. This copy is still associated with the same instance data as the original reference (until the reference variable is assigned to a new object). Call-by-reference is not necessarily required for a function to modify a parameter."} - \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions}{link}.
%   % \item Functions can be locally pure and/or globally pure https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/refactoring-into-pure-functions
%   \item Control flow analysis
%   % \item Could talk about Haskell in which all functions are pure and all values are immutable
%   \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/}{Delegates} and \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/anonymous-functions}{anonymous functions}.
%   \item Implicit and explicit variable declarations (C\# handles both)
%   \item \href{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/identifier-names}{Identifiers} are the names of types, members variables or namespaces used in source code. They reference \href{https://docs.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/work-with-semantics#symbols}{symbols}, representing a declared namespace, type, method, field, variable, etc. The compiler's process of associating identifiers with symbols is called \textit{binding}~\cite{microsoft-semantic-analysis}. % TODO explain symbols and identifiers
%   \item Closures and how objects can be considered closures (if fields are \texttt{readonly}?), and whether or not they should be considered pure.
% \end{itemize}

\section{The C\# language and .NET} \label{sub:the-csharp-language}
C\# is a type safe object oriented programming language developed by Microsoft~\cite{albahari2003nutshell}. C\# is syntactically quite similar to C, C++ and Java, and includes features like nullable types, enumerations, higher-order functions, and direct memory access~\cite{intro-to-Csharp}. While C\# historically has primarily been used for writing code for Windows platforms only, C\# has recently spread to most other platforms, including mobile, due to its increased cross-platform support~\cite{albahari2003nutshell}.

C\# applications run in the .NET ecosystem~\cite{intro-to-Csharp}. There are multiple implementations of .NET, including .NET Core and the .NET Framework~\cite{intro-to-Csharp}. .NET includes a virtual execution environment called the common language runtime (CLR) on which C\# programs run, as well as a common set of class libraries~\cite{albahari2003nutshell}. Before execution C\# source code is compiled to the so called intermediate language (IL) and stored on disk~\cite{intro-to-Csharp}. Upon execution the IL code is just-in-time-compiled to native machine instructions that can be executed by the operating system~\cite{intro-to-Csharp}.

Similarly to many other programming languages, functions in C\# are generally referred to as \textit{methods}~\cite{albahari2003nutshell}. These two terms will be used interchangeably in this thesis. Each method belongs to a \textit{class}, which is an encapsulations of data and behaviours~\cite{albahari2003nutshell}. C\# also supports anonymous functions~\cite{albahari2003nutshell}.

\subsection{What makes a C\# method pure?} \label{sub:What makes a Cs program functional?}
\autoref{fig:impure-example} and \autoref{fig:pure-example} illustrate two very simple examples of pure and impure code, respectively. In \autoref{fig:impure-example} the function \texttt{addOne()} is impure because it is writing to the variable \texttt{number} which was defined outside \texttt{addOne()}'s scope, which is a side-effect. \autoref{fig:pure-example} illustrates how \texttt{addOne()} can be rewritten to a pure function while preserving the program's semantics.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public class Program {
      static int number = 42;

      public static void addOne() {
        number += 1; // this is a side-effect
      }

      public static void Main() {
        addOne();
        Console.WriteLine(number); // outputs 43
      }
    }
  \end{lstlisting}
  \caption{A simple example of \textit{impure} code due to a side-effect.}
  \label{fig:impure-example}
\end{figure}

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public class Program {
      public static int addOne(int number) {
        return number + 1; // this method is now pure
      }

      public static void Main() {
        int number = 42;
        number = addOne(number);
        Console.WriteLine(number); // outputs 43
      }
    }
  \end{lstlisting}
  \caption{This is how \texttt{addOne()} from the example in \autoref{fig:impure-example} can be rewritten and used as a \textit{pure} function.}
  \label{fig:pure-example}
\end{figure}

Function parameters preceded with the \texttt{in} keyword are passed by reference and read-only inside the function~\cite{microsoft-in-modifier}. This means that input parameters marked with \texttt{in} cannot be re-assigned inside the function, which may suggest functional purity. Consider the example in \autoref{fig:in-example1}, where the parameter \texttt{number} is preceded by the \texttt{in} keyword. Because of this, modifying it inside the function will raise an error.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    int globalValue = 42;
    addOne(globalValue);
    Console.WriteLine(globalValue); // value is still 42

    void addOne(in int number) // note the `in` keyword
    {
      number += 1; // illegal assignment will raise error CS8332
    }
  \end{lstlisting}
  \caption{Assignment to the parameter \texttt{number} which is preceded with \texttt{in} raises an error~\cite{microsoft-in-modifier}.}
  \label{fig:in-example1}
\end{figure}

However, \texttt{in} is not a purity guarantee. Consider the example in \autoref{fig:in-example2}. The \texttt{in} keyword before the argument \texttt{list} ensures that \texttt{list} is read-only. This prevents \texttt{list} from being re-assigned after instantiation, but it doesn't prevent the data structure which \texttt{list} refers to from being modified~\cite{buchanan-static-lists}. In C\# there are two kinds of types: \textit{value types} and \textit{reference types}~\cite{microsoft-types}. Value types directly contain their data, while reference types -- also known as objects -- are simply pointers that refer to the location of their data.  Even though strings are of the reference type they are immutable, meaning that they cannot be modified after being created~\cite{microsoft-strings}. Therefore, value types and strings are passed to methods by value, which means that a method that modifies a value type parameter only modifies it locally, which doesn't affect its purity.

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    List<int> globalValue = new List<int>{42};
    addOne(globalValue);
    globalValue.ForEach(Console.WriteLine); // list is now {42, 1}

    void addOne(in List<int> list) // note the `in` keyword
    {
      list.Add(1); // this will _not_ raise an error even though
                   // Add(1) modifies the list
    }
  \end{lstlisting}
  \caption{The expression \texttt{list.Add(1)} which writes a value to \texttt{list} is allowed, even though \texttt{list} is read-only due to its preceding \texttt{in} keyword.}
  \label{fig:in-example2}
\end{figure}

Since the \texttt{in} keyword does not entirely prevent methods modifying their input parameters of reference type, and mutations to parameters of value type are not visible outside of methods regardless of the \texttt{in} keyword, it does not help us to determine the purity of a method.

\subsection{The .NET Abstract Syntax Tree and the CodeAnalysis library} \label{The .NET Abstract Syntax Tree and the CodeAnalysis library}

% Abstract syntax trees in general
Abstract syntax trees (ASTs) are the primary data structure used when analysing source code~\cite{microsoft-work-with-syntax}. It encapsulates every piece of information held in the source code~\cite{microsoft-work-with-syntax}. A syntax tree generated by a parser can be be re-built into the exact same text that was originally parsed~\cite{microsoft-work-with-syntax}.

The abstract syntax tree (AST) generated from a given piece of C\# code by Microsoft's code analysis library \texttt{Microsoft.CodeAnalysis} represents the lexical and syntactic structure of the C\# program~\cite{microsoft-work-with-syntax}. The tree consists primarily of \textit{syntax nodes} which represent syntactic constructs including declarations, statements, clauses and expressions~\cite{microsoft-work-with-syntax}. Each node is derived from the \texttt{Syntax}-\texttt{Node} class~\cite{microsoft-work-with-syntax}. Every node is non-terminal, meaning that they always have children - either other nodes or \textit{tokens}~\cite{microsoft-work-with-syntax}. Tokens are the smallest syntactic pieces of the program, consisting of keywords, identifiers, literals and punctuation~\cite{microsoft-work-with-syntax}.

% An \textit{expression} consists of zero or more operators with one or more operands, which can be evaluated to a single value, method, object or namespace.
% https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expressions

\subsection{C\# Events} \label{sub:Events}
Events are a way for classes or object to notify other classes or objects when something happens~\cite{microsoft-events}. The class raising the event is called the \textit{publisher} and the class handling the event is called the \textit{subscriber} (there can be more than one subscriber)~\cite{microsoft-events}. When an event is raised the subscriber's handler method is executed. Since events clearly are side-effects, a method that raises events or handles events is not considered pure

\subsection{Impure built-in C\# methods} \label{sub:Impure-built-in-methods}
The following methods that are built into C\# and are non-deterministic~\cite{dixin2015}:

\begin{itemize}
  \item \texttt{Console.Read}, \texttt{Console.ReadLine}, \texttt{Console.ReadKey}, \texttt{DateTime\allowbreak.Now} and \texttt{DateTimeOffset.Now} depend on the outside world.
\item \texttt{Random.Next}, \texttt{Guid.NewGuid} and \texttt{System.IO.Path.GetRandom}-\\\texttt{\allowbreak FileName} give random output.
\end{itemize}

The following methods that are built into C\# and have side-effects~\cite{dixin2015}:

\begin{itemize}
  \item \texttt{System.Threading.Thread.Start} and \texttt{Thread.Abort} mutate states.
  % \item \texttt{int.TryParse} and \texttt{Interlocked.Increase}
  \item \texttt{Console.Read}, \texttt{Console.ReadLine}, \texttt{Console-ReadKey}, \texttt{Console.\allowbreak Write} and \texttt{Console.WriteLine} produce console I/O.
  \item \texttt{System.IO.Directory.Create}, \texttt{Directory.Move}, \texttt{Directory.}\\\texttt{Delete}, \texttt{File.Create}, \texttt{File.Move}, \texttt{File.Delete}, \texttt{File.ReadAll\allowbreak }- \texttt{Bytes} and \texttt{File.WriteAllBytes} produce file system I/O.
\item \texttt{System.Net.Http.HttpClient.GetAsync}, \texttt{HttpClient.Post}- \\\texttt{Async}, \texttt{HttpClinet.PutAsync} and \texttt{HttpClient.DeleteAsync} produce network I/O.
  \item \texttt{IDisposable.Dispose} interacts with the program's environment.
\end{itemize}

The fact that previously mentioned methods are non-deterministic or have side-effects means that we know for sure that they are impure, which means that any function that uses them is also impure.

\subsection{.NET Code Contracts} \label{sub:Code contracts} % kanske ta bort eller flytta till Backgrounds?
.NET code contracts are used to define pre- and postconditions, as well invariants for pieces of code -- some which can be checked statically and some at runtime~\cite{microsoft-code-contracts}. One available code contract is the \texttt{[Pure]} attribute, which indicates that the method is pure~\cite{microsoft-code-contracts}. However, current analysis tools do not enforce that methods marked with \texttt{[Pure]} actually are functionally pure~\cite{microsoft-pure-attribute}, and so the attribute does not guarantee functional purity. Microsoft defines pure methods as methods that don't modify any pre-existing state, i.e. methods can only modify objects that were created \textit{after} the method was called~\cite{microsoft-code-contracts}. The following code elements are assumed by the code contract tools to be pure~\cite{microsoft-code-contracts}:

\begin{itemize}
  \item Methods or types marked with \texttt{[Pure]} (for types marked with \texttt{[Pure]} this should apply to to all the type's methods).
  \item Property get accessors.
  \item Operators.
  \item Any method with a fully qualified name starting with \texttt{System.Diagnost\-ics.Contracts.Contract}, \texttt{System.String}, \texttt{System\-.IO.Path}, or \texttt{System.Type}.
  \item Any called delegate with the \texttt{[Pure]} attribute. Delegates are basically function pointers.
\end{itemize}

\section{Problems with determining purity in object oriented languages} \label{sec:Problems with determining purity in object oriented languages}

Analyzing functional purity in object oriented programming languages yields a number of dilemmas. This section describes them, as well as how they were dealt with.

\subsection{Inheritance and method overriding} \label{sub:inheritance}

When calling an object parameter's method, because of inheritance and method overriding we can never be sure of which method implementation will be called. Consider the following example~\cite{pearce2011jpure}:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    void f(List<string> x) {
      x.Add("Hello");
    }
  \end{lstlisting}
  \caption{Since \texttt{x} can be of any subclass of \texttt{List} we can never be sure of \texttt{x.Add()}'s implementation.}
  \label{fig:inheritance-example}
\end{figure}

Because the parameter \texttt{x} can be of any subclass of \texttt{List} we can not for sure know the implementation of \texttt{x.Add()}, nor therefore can we be certain of \texttt{x.Add()}'s purity. Thus, we can not determine \texttt{f()}'s purity.

One solution to this that David J. Pearce suggests is to demand that pure methods only are overridden by methods that are also pure~\cite{pearce2011jpure}. Therefore, if a method \textit{m} is overridden by at least one impure method, \textit{m} is assumed to be impure.

This means that in the example in \autoref{fig:inheritance-example}, the function \texttt{f()} is pure iff all methods that override \texttt{List.Add()} are pure.

\subsection{Modifying a fresh object} \label{sub:modifying-fresh-objects}

If an object \textit{o} is allocated inside the analysed method \textit{m}, the object \textit{o} is said to be \textit{fresh}~\cite{pearce2011jpure}. To modify \textit{o}'s state we might call a method that looks impure (since that method would have the side-effect of modifying \textit{o}). However, this method should not make \textit{m} impure since \textit{o} is fresh, which means that the modification of \textit{o} is not a side-effect of \textit{m}.

Consider the following example:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public List<String> Foo() {
      List<String> list = new List<String>();
      list.Add("hello"); // this changes list's state
      return list;
    }
  \end{lstlisting}
  \caption{\texttt{List.Add()} has a side-effect because it modifies the list \texttt{list}. However, since \texttt{list} is fresh \texttt{Foo()}'s purity is not affected.}
  \label{fig:fresh-object-example}
\end{figure}

Because \texttt{list.Add()} in \autoref{fig:fresh-object-example} modifies the state of \texttt{list}, which is a side-effect of \texttt{Add()}, \texttt{Add()} cannot be a pure method. Does that mean that the function \texttt{Foo()} calling \texttt{list.Add()} is also impure, because it calls a non-pure method? In general functions that invoke impure functions are themselves impure. However, this is not the case for \texttt{Foo()}. Recall the definition of purity in \autoref{def:functional-purity}:

\begin{quote}
  \textit{A function is functionally pure if it is side-effect free and deterministic}.
\end{quote}

Because the function \texttt{Foo()} only modifies an object exclusively visible inside the function, \texttt{Foo()} does not have any side-effect. The function is also deterministic since it does not read any value outside of the function besides its own parameters, which it in this case doesn't have. This means that \texttt{Foo()} is pure. To solve this we introduce the purity level \textit{locally impure}:

\begin{definition}[Local Impurity] \label{def:locally-impure}
  Any method that is functionally pure except for modifying any of its own object's fields is locally impure.
\end{definition}

Consider the following example:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public A Foo() { // pure
      A a = new A();
      a.Increment();
      return a;
    }

    public class A {
      public int value = 0;

      public void Increment() { // locally impure
        value++;
      }
    }
  \end{lstlisting}
  \caption{Since \texttt{Foo()} modifies a fresh object with a locally impure method \texttt{Foo()} is still pure.}
  \label{fig:locally-impure-example}
\end{figure}

The method \texttt{Increment()} in \autoref{fig:locally-impure-example} is locally impure because it modifies its object's field \texttt{value} but doesn't have any other side-effects. A function that calls a fresh object's locally impure method \textit{m} is not contaminated by \textit{m}'s local impurity.

There is however one more way to modify a fresh object: to pass it as an argument to a method that alters its state. Consider the following example:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
    public A Foo() { // pure
      A a = new A();
      A.Increment(a);
      return a;
    }

    public class A {
      public int value = 0;

      public static void Increment(A a) { // parametrically impure
        a.value++;
      }
    }
  \end{lstlisting}
  \caption{Since \texttt{Foo()} modifies a fresh object with a parametrically impure method \texttt{Foo()} is still pure.}
  \label{fig:parametrically-impure-example}
\end{figure}

Because the method \texttt{Increment()} in \autoref{fig:parametrically-impure-example} modifies its input parameter object it cannot be considered truly pure. However, since \texttt{Foo()} uses \texttt{Increment()} to modify a fresh object \texttt{Foo()} is still pure. I have chosen to categorize methods like this \textit{parametrically impure}:

\begin{definition}[Parametrical impurity] \label{def:parametrically-impure}
  Any method that is pure except for modifying the state of its input is parametrically impure.
\end{definition}

There are two ways for a method to modify its input parameters: either by mutating a value belonging to a reference type input parameter, i.e. an object's field or property, or the cell of an array; or by calling a locally impure method belonging to a parameter object.

The key thing in both the example where a method \textit{m} calls locally or parametrically impure methods is that they modify a fresh object, which therefore doesn't affect \textit{m}'s purity level. So as long as the analyzed method \textit{m} or any of its called methods don't perform any truly impure action like I/O operations (e.g. writing to a file on the file system) or throw exceptions, \textit{m} is pure.

In Python, which also is an object-oriented programming language, the instance object equivalent to C\#'s \texttt{this} (in Python usually referred to as \texttt{self}) always has to be explicitly listed as the first parameter of a method when declaring it, and gets automatically passed as as the method's first argument when the method is called~\cite{python-classes}. Similarly, in C\# the reference to the instance object \texttt{this} is in fact an implicit parameter for all methods~\cite{michaelis2018essential}. This means that a method \textit{m} that reads the value of a field of its own object still is considered deterministic even though that field has not been explicitly added as a method parameter. Recall from \autoref{def:determinism} that \textit{m} is deterministic if \textit{m}'s output depends purely on its input parameters. This still holds with \textit{m}, since its entire object \texttt{this} where that field lives gets implicitly passed as an argument to \textit{m}.

Moreover, the implicit passing of \texttt{this} to every method also implies that any method that is locally impure is also parametrically impure. As \autoref{def:locally-impure} states, a method \textit{m} that is locally impure modifies its object \texttt{this}'s fields. Since \texttt{this} is always the first parameter of any method, this means that modifying a field in \texttt{this} always means modifying a parameter, which implies parametrical impurity.

Although local impurity implies parametrical impurity, the opposite does always necessarily hold since a method could be parametrically impure without modifying a field in \texttt{this}. Therefore, distinguishing between local and parametrical impurity could be of value, for instance when implementing other methods in the same class; since locally impure methods modify the state of their object, and those object-local side-effects are visible for methods inside the same object.

\subsection{Non-static property pointing to a static field} \label{sub:non-static-property}
\textit{Properties} in C\# are special \texttt{get} and \texttt{set} methods for reading, computing or writing to values of object fields~\cite{microsoft-properties}. Properties can, just like other fields or methods be set to \texttt{static}, which means that they are assigned to the class rather than any instantiated object. If a method reads from or modifies a static property, that method would be considered to be non-deterministic or to have a side-effect, i.e. it would be impure, because static fields are accessible anywhere in a program.

However, properties can also be non-static but still read or modify static fields. Consider the following:

\begin{figure}[H]
  \centering
  \begin{lstlisting}
  public class Foo {
    public Swede gert = new Swede();

    public void Bar() {
      Swede stina = new Swede();
      stina.Nationality = "Norway"; // assignment to non-static field

      Console.WriteLine(gert.Nationality); // prints "Norway"
    }

    public class Swede {
      static string nationality = "Sweden"; // This field is static

      public string Nationality { // This property is non-static
        get { return nationality; }
        set { nationality = value; }
      }
    }
  }
  \end{lstlisting}
  \caption{What looks like a non-static assignment to an object property does in fact mutate a static field, which is a clear side-effect of \texttt{Bar()}.}
  \label{fig:non-static-property-example}
\end{figure}

In the example in \autoref{fig:non-static-property-example}, the method \texttt{Bar()} assigns to the field \texttt{Nationality} of the fresh object \texttt{stina}. Because the property \texttt{Nationality} is non-static it, it might look like a pure action at a first glance. But since the property writes method \texttt{get} itself modifies a static field, the \texttt{Bar()}'s assignment to \texttt{Nationality} is in fact a side-effect, which alters all \texttt{Swede} objects' \texttt{Nationality}. Therefore, it is not enough to check if a property is static in order to determine whether a read or write is pure, but the property's \texttt{get} and \texttt{set} have to be checked as well.

% Perhaps ignore cases like this for simplicity?

\subsection{Method overloading} \label{sub:Method-overloading}
While method overloading is not unique to object oriented programming, it seems appropriate to mention here as well. Method overloading is when there multiple method implementations share the same method name but have different function signatures, i.e. return types, parameter types and/or number of parameters~\cite{albahari2003nutshell}. One could consider all overloads to be the same method \textit{m}, since they share the same name. However, this would make it difficult to calculate \textit{m}'s purity level, since one overload of \textit{m} could be pure, while another overload is impure. Which purity level should then be given to \textit{m}?

Instead, when given an overloaded method named \textit{m} the analysis treats each overload of \textit{m} as a unique method, independent of other overloads. This way overloads with different purity levels can co-exist in the result of an analysis. Because overloads by definition share the same name, in order to differentiate them in this thesis the notation $m_1$, $m_2$, $m_3$, ... is used, where $m_1$ denotes the first implementation of the method \textit{m}, $m_2$ denotes the second, and so on.

\section{The analysis method} \label{sec:the-analysis-method}
There are five kinds of functional purity levels for: \textit{pure}, \textit{locally impure}, \textit{parametrically impure}, \textit{impure}, and \textit{unknown}. The latter was added for the case where the purity level of a method cannot be determined.

Traverse the Abstract Syntax Tree (AST) and build the \textit{dependency set} for each function, i.e. the set of calls inside a function. If during the traversal a call or reference to a compiled method or a field is found, mark the caller function's purity as \textit{unknown}.

Since object constructors can perform impure actions just like methods, they are in this section included in the term "function".

Because of the problem with inheritance and method overriding discussed in \autoref{sub:inheritance}, when going through the AST and building the dependency set, if any object parameter's method is overridden by any of its subclasses, add all the overridden methods to the calling function's dependency set. Each function together with its dependency set is stored in a lookup table where the key is the function identifier \textit{f} and the values are \textit{f}'s dependency set $D_f$ as well as \textit{f}'s purity level \textit{p}. The purity of each function is initialized to \textit{pure}, except those that were explicitly marked \textit{unknown}.

Let the \textit{working set} \textit{W} be the set of all functions with empty dependency sets. Whenever a function's dependency set becomes empty, that function is added to \textit{W}. Calculate the purity level for each function in \textit{W} as described in the checklist in \autoref{sub:checklist-to-determine-the-purity-level} below. Then, for each function \textit{f} in \textit{W}, propagate the impurity of those with purity level \textit{impure} or \textit{unknown} to the functions dependant on \textit{f}, "contaminating" them. Remove \textit{f} from the dependency sets of all functions that depend on \textit{f}, as well as from the working set \textit{W}. Add functions that now have empty dependency sets to \textit{W}. Repeat this process until there are no more changes to the lookup table, in which case the analysis is complete. Each function in the lookup table will now have been marked with its corresponding purity level. Because the purity level of each function was initialized to \textit{pure}, any function who's purity level was unaffected by the analysis will be marked \textit{pure} at the end of the analysis.

Ignoring the purity level \textit{unknown}, the other four purity levels can be ordered in terms of impurity, from least impure to most impure, like so: \textit{pure} $<$ \textit{locally impure} $<$ \textit{parametrically impure} $<$ \textit{impure}. A method \textit{m}'s purity level should during the analysis only be updated if the new purity level is less impure than \textit{m}'s current one. For instance, if in an arbitrary instance during the analysis, \textit{m} has the purity level \textit{parametrically impure}, and a check determines its purity level to be \textit{impure}, it's purity level should be updated since \textit{impure} is more impure than \textit{locally impure}. However, if for instance another check says that \textit{m} is \textit{locally impure}, its purity level should not be updated since \textit{locally impure} is less impure than \textit{impure}.

\subsection{Checklist to determine the purity level} \label{sub:checklist-to-determine-the-purity-level}

% A method can have multiple impurity levels.
The following is how to determine the purity level \textit{p} for the currently analyzed method \textit{m}.

\begin{enumerate}
  \item If any object field or property of the currently analyzed method \textit{m}'s object is read from or modified, mark \textit{m} as \textit{locally impure}. \label{itm:locally-impure}
    % TODO: mention indirectly modifing fields by modifing variables that point to fields
    %   var foo = field;
    %   foo.bar = null;
  \item If \textit{m} calls a locally impure method belonging to \textit{m}'s object (i.e. \texttt{this}) \textit{m} is marked \textit{locally impure}.
  \item If the method \textit{m} reads or modifies a static field of any class or object, \textit{m} is marked \textit{impure}. This is because reading a static field is a non-deterministic action, and modifying a static field is a side-effect since it mutates the field for all instantiations of that object's class. \label{itm:static-impure}
  \item If the method \textit{m} calls a \textit{locally impure} method of an object assigned to a static field of any class or object, \textit{m} is marked \textit{impure}.
  \item If the currently analyzed method \textit{m} calls an input parameter's method $m_p$ and $m_p$ is overridden by any locally impure and/or parametrically impure method, $m_p$ is temporarily marked with the impurities of all the overriding methods in the context of the analysis of the current method \textit{m}. If $m_p$ is overridden by any impure method, \textit{m} is permanently marked as impure.
    % Moreover:
    % \begin{itemize} % Maybe these are covered by other cases?
    %   \item If $m_p$ is overridden by any impure method, \textit{m} is marked impure.
    %   \item If $m_p$ is overridden by any locally impure method, \textit{m} is marked parametrically impure.
    % \end{itemize}
  \item If the analyzed method \textit{m} modifies an input parameter of reference type, mark \textit{m} as \textit{parametrically impure}. This could be done in a couple of ways: \label{itm:parametrically-impure}
    \begin{itemize}
      \item By calling an object type parameter's method that has been marked as \textit{locally impure}.
      \item By passing an object type parameter as an argument to a method that has been marked as \textit{parametrically impure}.
      \item By directly mutating a parameter object's field or property, or the cell of a parameter array.
    \end{itemize}
    If \textit{m} does at least one of the above, mark it as \textit{parametrically impure}.
  \item If a method returns \texttt{this} or passes it as an argument to a function it marked \textit{locally impure} since it is dependent on the state of its object, making it non-deterministic.
  \item Any method that raises an event is marked \textit{impure}. \label{itm:raises-event}
  \item Any method that raises an exception is marked \textit{impure}. \label{itm:raises-exception}
  \item Any method mentioned in the two lists of impure built-in C\# methods in \autoref{sub:Impure-built-in-methods} is marked \textit{impure}. \label{itm:impure-built-in}
  % \item Build a lookup table with all evaluated functions, their purity and their dependency set~\cite{pitidis2010purity}.
\end{enumerate}

We do not have to explicitly handle the case mentioned in \autoref{sub:modifying-fresh-objects} where fresh objects are modified with their own locally impure methods due to the fact that our definition of local purity includes determinism. Because if a non-fresh object \textit{o} is modified with its locally impure method, then we must have read the pointer to \textit{o} from a field outside the method, meaning that \textit{m} is non-deterministic and therefore locally impure. This is why we only propagate the purity level of \textit{impure} functions to their callers, and not \textit{local impurity} or \textit{parametrical impurity}. There are however two exceptions to this, which are covered by previously mentioned checks in our analysis:
\begin{itemize}
  \item The case of \textit{o} being a static field of an instantiated object has to be checked.
  \item The case of \textit{o} being a parameter to \textit{m} has to be checked because this is parametrical impurity.
\end{itemize}

\subsection{Example} \label{ssub:Example}
\autoref{fig:example-code} contains a simple implementation of a linked list in C\#. In order to illustrate all types of impurities, the implementation contains some odd design choices.

The method \texttt{Length()} takes a \texttt{LinkedList} as input and returns its length. This method is deterministic since it only depends on its input argument, and it is side-effect free since it does not mutate any value that exists outside its scope, including its parameter object. Therefore, \texttt{Length()} is pure.

\texttt{Add()} appends an \texttt{Object} to the end the list. It is not deterministic since it reads from and mutates the state of \texttt{this} in multiple locations. For instance, the first location where it modifies \texttt{this} is where it assigns a \texttt{new Node} to \texttt{head}, which is a field that is visible outside the method. Therefore, \texttt{Add()} is locally impure -- it depends on and/or mutates the state of its object.

\texttt{Remove()} deletes an item at a given index from a \texttt{LinkedList} which is passed as an argument to the method. To simplify the method and reduce its size, its input list is assumed to be non-empty and the index value is assumed to be a valid position inside the list. \texttt{Remove()} only operates based on its input and is therefore deterministic. However, it does modify fields of the parameter \texttt{list} and is therefore parametrically impure.

The first overloading of the method \texttt{Concatenate()} modifies the static class field \texttt{numberOfConcatenates} and therefore has a side-effect, making it impure. The second overloading of \texttt{Concatenate()} depends on the former method, and is therefore also impure. The static field \texttt{numberOfConcatenates} was added to illustrate the propagation of impurity.

\begin{figure}[H]
  \centering
  \begin{minipage}[t]{0.52\linewidth}
    \begin{lstlisting}[basicstyle={\fontsize{8}{9}\ttfamily}]
  public class LinkedList
  {
    private Node head;
    private Node tail;

    // Static counter used by Concatenate()
    public static int numberOfConcatenates;

    // Returns length of list
    public static int Length(LinkedList list)
    {
      Node current = list.head;
      int length = 0;

      while (current != null)
      {
        length++;
        current = current.next;
      }
      return length;
    }

  // Removes item at an index from list.
  // Assumes that list is non-empty and
  // that index is non-negative and less
  // than list's length
  public static void Remove(int index, LinkedList list)
  {
    if (index == 0) {
      list.head = list.head.next;
    }
    else {
      Node pre = list.head;

      for (int i = 0; i < index - 1; i++)
      {
        pre = pre.next;
      }
      pre.next = pre.next.next;

      // If index referes to the last element
      if (index == Length(list))
      {
          list.tail = pre;
      }
    }
  }
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{0.46\linewidth}
    \begin{lstlisting}[basicstyle={\fontsize{8}{9}\ttfamily}]
  // Appends data to the list
  public void Add(Object data)
  {
    if (LinkedList.Length(this) == 0)
    {
      head = new Node(data);
      tail = head;
    }
    else
    {
      Node addedNode = new Node(data);
      tail.next = addedNode;
      tail = addedNode;
    }
  }

  // Concatenates two lists by
  // appending a list to the end of
  // this list
  public void Concatenate(LinkedList list)
  {
    if (head == null) head = list.head;
    else
    {
      this.tail.next = list.head;
      this.tail = list.tail;
      list.head = this.head;

      // This gives the method a
      // side-effect
      numberOfConcatenates++;
    }
  }

  // Overloading of Concatenate that
  // allows passing both lists as
  // parameters
  public static void Concatenate(LinkedList l1, LinkedList l2)
  {
    l1.Concatenate(LinkedList l2);
  }

  private class Node
  {
    public Node next;
    public Object data;

    public Node() { }

    public Node(Object data)
    {
      this.data = data;
    }
  }
}
    \end{lstlisting}
  \end{minipage}
  \caption{Simple implementation of a linked list. For the sake of this example, it contains some odd design choices.}
  \label{fig:example-code}
\end{figure}

The analysis starts off by building the dependency set for each function and setting all purities to \textit{pure}, as seen in \autoref{tab:lookup-table1}.

\begin{table}[H]
  \caption{Initial state of the lookup table after computing each function's dependency set. The working set $W$ is the set of all functions with empty dependency sets.}
  \label{tab:lookup-table1}
  \centering
  \begin{tabular}{|l|c|c|}
    \hline
    $f$                         & $D_f$                     & $p$    \\ \hline
    \texttt{Length()}           &                           & \textit{pure} \\
    \texttt{Remove()}           & \texttt{Length()}         & \textit{pure} \\
    \texttt{Add()}              & \texttt{Length()}         & \textit{pure} \\
    \texttt{Concatenate$_1()$}   &                           & \textit{pure} \\
    \texttt{Concatenate$_2()$}   & \texttt{Concatenate$_1()$} & \textit{pure} \\ \hline
  \end{tabular}
  \\
  $W$ = \{\texttt{Length()}, \texttt{Concatenate$_1()$}\}
\end{table}

The working set $W$ is the set of all functions in the lookup table with empty dependency sets, which in this case is \texttt{Length()} and \texttt{Concatenate$_1()$} (the first overloading of \texttt{Concatenate()} in \autoref{fig:example-code}). We now go through each item in the checklist in \autoref{sub:checklist-to-determine-the-purity-level} for each method in $W$, and check which items apply to the methods:

Since none of the items in the checklist apply to \texttt{Length()}, its purity level remains \textit{pure}. As for the method \texttt{Concatenate$_1()$} the items \ref{itm:locally-impure}, \ref{itm:static-impure} and \ref{itm:parametrically-impure} apply to it. Item \ref{itm:parametrically-impure} since \texttt{Concatenate$_1()$} modifies the fields \texttt{list} and \texttt{tail} of its input parameter, item \autoref{itm:locally-impure} since it modifies its own \texttt{head} and \texttt{tail}, and \autoref{itm:static-impure} since \texttt{Concatenate()} modifies the static class field \texttt{numberOfConcatenates}. Thus \texttt{Concatenate$_1()$} should marked with the purity levels \textit{locally impure}, \textit{parametrically impure} and \textit{impure}, and since \textit{impure} is the impurest of the three the method gets marked \textit{impure}.

Since \texttt{Concatenate$_1()$}'s purity level was marked \textit{impure} its purity level is propagated to its callers, which in this case is \texttt{Concatenate$_2()$}. \texttt{Concatenate$_1()$} is then removed from the dependency set of \texttt{Concatenate$_2()$}, and \texttt{Length()} is removed from \texttt{Add()} and \texttt{Remove()}'s depenedency sets. The methods \texttt{Length()} and \texttt{Concatenate$_1()$} are now removed from the working set $W$, and \texttt{Remove()}, \texttt{Add()} and \texttt{Concatenate$_2()$} are added to $W$, as their dependency sets now are empty. At this point the state of the lookup table is as shown in \autoref{tab:lookup-table2}.

\begin{table}[H]
  \caption{\texttt{Remove()} and \texttt{Concatenate$_1()$}'s purity levels have been updated, and after analysing them they are removed from the dependency set of their callers. Also \texttt{Concatenate$_1()$}'s purity level has been propagated to \texttt{Concatenate$_2()$}.}
  \label{tab:lookup-table2}
  \centering
  \begin{tabular}{|l|c|c|}
    \hline
    $f$                        & $D_f$                  & $p$                            \\ \hline
    \texttt{Length()}          &                        & \textit{pure}                         \\
    \texttt{Remove()}          &                        & \textit{parametrically impure}        \\
    \texttt{Add()}             &                        & \textit{pure}                         \\
    \texttt{Concatenate$_1()$}  &                        & \textit{impure}                       \\
    \texttt{Concatenate$_2()$}  &                        & \textit{impure}                       \\ \hline
  \end{tabular}
  \\
  $W$ = \{\texttt{\texttt{Remove()}, Add()}, \texttt{Concatenate$_2()$}\}
\end{table}

Now we perform the same actions again with the new working set $W$ = \{\texttt{Remove()}, \texttt{Add()}, \texttt{Concatenate$_2()$}\}, starting with \texttt{Remove()}. Out of the items in the checklist in \autoref{sub:checklist-to-determine-the-purity-level}, \autoref{itm:parametrically-impure} applies since \texttt{Remove()} directly mutates its input parameter \texttt{list} in multiple locations. Therefore \texttt{Remove()} is marked \textit{parametrically impure}.

As for \texttt{Add()} \autoref{itm:locally-impure} applies to it since \texttt{Add()} modifies its object in multiple locations, for instance by assigning to the field \texttt{tail}, and so \texttt{Add()}'s purity level is set to \textit{locally impure}.

Looking at \texttt{Concatenate$_2()$}, none of the items in the checklist apply, and so it remains its purity level \textit{impure} that was propagated to it from \texttt{Concatenate$_1()$}.

\texttt{Remove()}, \texttt{Add()} and \texttt{Concatenate$_2()$} are then removed from $W$.

\begin{table}[H]
  \caption{\texttt{Add()}'s purity level has been updated to \textit{locally impure}. Since $W$ is now empty, this is the final result of the analysis.}
  \label{tab:lookup-table3}
  \centering
  \begin{tabular}{|l|c|c|}
    \hline
    $f$                        & $D_f$                  & $p$                            \\ \hline
    \texttt{Length()}          &                        & \textit{pure}                         \\
    \texttt{Remove()}          &                        & \textit{parametrically impure}        \\
    \texttt{Add()}             &                        & \textit{locally impure}               \\
    \texttt{Concatenate$_1()$}  &                        & \textit{impure}                       \\
    \texttt{Concatenate$_2()$}  &                        & \textit{impure}                       \\ \hline
  \end{tabular}
  \\
  $W$ = \{\}
\end{table}

At this point the working set $W$ is empty, and so there can be no more changes to the lookup table. Therefore the analysis stops here. The final result is thus what is shown in the lookup table in \autoref{tab:lookup-table3}. Looking at the table we can see that \texttt{Length()} is the only truly pure method out of the five. Thus we can conclude that \texttt{LinkedList}'s total purity level is 1/5 = 20\% functionally pure.

\section{Implementation of the analysis tool CsPurity} \label{sec:Implementation of the analysis tool}
% \item For performance reasons, first check general stuff and then do more specific checks.

Because there was a clear goal for the software and it's requirements, test driven development was used when implementing the analysis tool in C\#.

Because .NET has many libraries in the form of pre-compiled assemblies, the source code of the functions used in these libraries is not always available. Because of this, the purity level "unknown" has to be added for when we cannot compute a function's purity level.

The implementation of the code analysis tool is called \textit{CsPurity} and is built using .NET Core and C\#. It can be compiled, run and tested from the command line using the command \href{https://docs.microsoft.com/en-us/dotnet/core/tools/}{\texttt{dotnet}}, followed by \texttt{run}, \texttt{build} or \texttt{test}, respectively. Upon calling the program it can be provided either with a single file to be analyzed, or a directory. In the second case, all C\#-files in the directory and all sub-directories are analyzed as one program.

To find the declaration/definition of symbols (in the form of \texttt{IdentifierNameSyn\allowbreak tax}) the method \texttt{SemanticModel.GetSym\allowbreak bolInfo()} is used, which uses the semantic model of the program.

The tool is not able to determine the purity of methods that invoke delegate functions. Delegate functions are higher-order functions that invoke methods passed to them as arguments. Invoking delegate functions is done relatively sparsely in C\# and handling them would require a disproportional amount of extra work. The delegate functions themselves however are analyzed just like regular methods.

Something that was realized while implementing the tool is that the C\# compiler does not perform tail call recursion. Recursion is a very common technique when it comes to functional programming. The initial implementation of CsPurity built the lookup table by calculating each function's dependency set recursively. When analyzing larger code bases the program crashed due to an immense memory usage. Therefore, its recursive implementation had to be changed to an iterative one which worked C\# better.

TODO

\section{Results and discussion} \label{sec:results-and-discussion}
The implemented analysis program CsPurity works backwards through the analyzed program's function dependencies and for each function visited its functional purity level is calculated. The purity levels \textit{impure} and \textit{unknown} also get propagated from callee to caller. Out of all ten items in the checklist in \autoref{sub:checklist-to-determine-the-purity-level}, the following three were implemented:

\begin{itemize}
  \item \autoref{itm:static-impure}: "If the method \textit{m} reads or modifies a static field of an object, \textit{m} is marked \textit{impure}".
  \item \autoref{itm:raises-exception}: "Any method that raises an exception is marked \textit{impure}".
  \item \autoref{itm:impure-built-in}: "Any method mentioned in the two lists of impure built-in C\# methods in \autoref{sub:Impure-built-in-methods} is marked \textit{impure}".
\end{itemize}

The reason why three out of the total ten checks were implemented was due to the sheer amount of time that the implementation took. After implementing the whole lookup table and all of its functionality, calculation of each method's dependency set, propagation of impurities from callee to caller, etc. there was not time left to implement every item in the checklist in a reasonable amount of time, and so the three items above were chosen. Because of this, CsPurity is unable to detect local and parametrical impurity, and can only detect full impurity caused by side-effects.

Due to the choice of including determinism in the definition of functional purity, which is not included in some definitions, the analysis could be somewhat simplified. The main advantage to including determinism is that we don't have to explicitly check whether potentially global (i.e. static) object fields are read from or modified by a function \textit{f}, in order to determine \textit{f}'s purity. As a long as a static variable appears in \textit{f} we know that \textit{f} is non-deterministic since it depends on a global state. On the other hand, if determinism were ignored we would have to check whether the static field is modified by \textit{f} or not -- or by some method called by \textit{f} -- in order to determine \textit{f}'s purity, which would be even trickier.

% One could however argue that objects are similar to closures, in which case a method reading the field of \texttt{this} would be considered pure, and not locally impure as it would be marked now.

CsPurity does not handle recursion, which if a recursive program is analyzed could cause it finish before all functions' purities have been calculated, because no more functions will be added to the working set. Support for recursive functions can be added by searching for independent strongly connected components~\cite{pitidis2010purity}.

% Static method purity is calculated as the percentage of all methods in the call graph that are pure~\cite{xu2007dynamic}.

CsPurity uses a blacklist of built-in impure C\# functions in order to spot functions that handle impure actions such as randomness and I/O. There may be other impure built-in similar functions that are not in the blacklist.

An alternative way to compare programs' total purity levels, i.e. the ratio between number of pure methods and the total number of methods, could be to profile each program and weight the purity level of each method depending on how often that method is called. For example, let's say that only 10\% of program \textit{A}'s methods are pure compared to program \textit{B} where 20\% of its methods are pure. Now say that \textit{A}'s pure methods make up 90\% of the total function calls during execution and \textit{B}'s pure methods only are called 10\% of the times during execution. In this case, one could argue that \textit{A} is purer than \textit{B} since it makes more calls to pure methods than impure ones compared to \textit{B}, even though \textit{B} has a higher ratio of the number of pure methods.

Because most methods use built-in C\# methods for which the source code is not necessarily public, a majority of the analyzed methods get the purity level \textit{unknown}. One way of tackling this was to search online for the source code of classes like \texttt{List}, run the analyzer on them and permanently store the calculated purity level for each method in a dictionary in the program, so that whenever a call to a built-in \texttt{List} method is made its purity level (if it is not \textit{unknown}) can be retrieved from the dictionary. However, this relies on the fact that the source code for a particular built in method is available online, and the process of searching for its code, running the analyser on it and adding any known result to the program's dictionary is cumbersome.

Since CsPurity is unable to detect local and parametrical impurity it cannot for certain determine the purity of any program. CsPurity does however identify true impurity -- the impurest purity level -- and does therefore compute a lower bound to a program's impurity, which is equivalent to an upper bound to the program's purity level. CsPurity does not however give a definite lower bound to a program's purity level. This is due to the fact that all methods' purity levels are initialized to \textit{pure}, and the purity level only changes if CsPurity detects a non-pure trait based on the checklist in \autoref{sub:checklist-to-determine-the-purity-level}. Since not every item in the checklist is implemented, we cannot know if a method was marked \textit{pure} in the result of an analysis because it truly was pure, or because it had a non-pure trait that the implementation cannot detect.

One could argue that if choosing between computing an upper or a lower bound to a program's purity level, a lower bound is more interesting to a programmer. However, due to the nature of the analysis method this requires fully implementing the method.

Another approach to handling called methods with unknown purity -- as opposed to marking their purity level \textit{unknown} -- would be to simply assume that any unknown method's purity level always is \textit{impure}, or to assume that it is always \textit{pure}. The more conservative approach of assuming that any unknown method is impure would mean that the upper bound for the program's total possible purity level would be moved down, which could potentially give a lower bound that is too low, since some of the unknown methods that were marked \textit{impure} could have been pure. Since the incomplete implementation does not give a lower bound, the assumption of impurity will have no effect on the lower bound.

For the same reason, assuming that any unknown method is \textit{pure} will also not affect any lower bound of the program's total purity level. The upper bound for the program's total purity level will in this case be the same as the \textit{unknown} approach. However, this assumption will be misleading with a complete implementation since it will potentially give false positives that indicate that some methods are pure when they are not. Therefore, since it clearly indicates to the user where the purity level could not be determined, the purity level \textit{unknown} seems to be the best choice here.

\subsection{Results from scanning implementation of linked list} \label{sub:results-from-scanning-the-example}
Following is the result of running the implemented analyzer CsPurity on the linked list program in \autoref{fig:example-code}. By looking at the result from running CsPurity and comparing it to the expected result in \autoref{ssub:Example} we can evaluate its performance.

\begin{figure}[htpb]
  \centering
  \begin{minipage}{\linewidth} % Forces code to be on same page
    \begin{lstlisting}
    METHOD                   PURITY LEVEL
    -------------------------------------
    LinkedList.Length        Pure
    LinkedList.Add           Pure
    LinkedList.Remove        Pure
    LinkedList.Concatenate   Impure
    LinkedList.Concatenate   Impure
    \end{lstlisting}
  \end{minipage}
  \caption{Result from running CsPurity on the linked list implementation in \autoref{fig:example-code}.}
  \label{fig:example-result}
\end{figure}

As seen in \autoref{fig:example-result} CsPurity correctly identifies the impurity of both overloads of \texttt{Concatenate()}, who's implementations can be seen in \autoref{fig:example-code}. CsPurity has thereby successfully spotted the first overload's side-effect and propagated its impurity to the second overload, which depends on the first.

However, the three other analyzed methods \texttt{Length()}, \texttt{Add()} and \texttt{Remove()}'s purity levels -- which are always initialized to \textit{pure} in the lookup table -- were unchanged by the analysis. As seen in \autoref{tab:lookup-table3}, \texttt{Length()}'s purity level should be unaffected and remain \textit{pure}. However, \texttt{Add()}'s and \texttt{Remove()}'s purity levels are not identified, since CsPurity only can detect methods with maximum impurity level \textit{impure} -- i.e. \autoref{itm:static-impure} in the checklist -- and not local or parametrical impurity.

Therefore, what we can say for sure about the linked list implementation based on the result in \autoref{fig:example-result} is that its purity level is \textit{at most} three pure methods out of a total of five methods, i.e. it is $\leq$ 3/5 = 60\% functionally pure. Since the true purity level of 20\% that we expect from \autoref{ssub:Example} is less than or equal to 60\%, the upper bound is correct.

TODO

% \subsection{Code base} \label{sub:Code base}
% \textbf{Mostly pure code}
% \begin{itemize}
%   \item \href{https://github.com/dotnet/roslyn/blob/master/src/Workspaces/SharedUtilitiesAndExtensions/Compiler/Core/Utilities/CompilerUtilities/ImmutableHashMap.cs}{\texttt{ImmutableHashMap.cs}} - has many methods marked with \texttt{[pure]}
%   \item \href{https://github.com/nodatime/nodatime/blob/master/src/NodaTime}{NodaTime} has many pure methods. NodaTime's \href{https://github.com/nodatime/nodatime/blob/master/src/NodaTime/AnnualDate.cs}{\texttt{AnnualDate.cs}} for instance has many pure methods not marked with \texttt{[pure]}
% \end{itemize}

% \textbf{Mostly impure code}
% \begin{itemize}
%   \item \href{https://github.com/SixLabors/ImageSharp/blob/master/src/ImageSharp}{ImageSharp}
%   \item \href{https://github.com/geaz/sharpDox}{sharpDox}
% \end{itemize}

% TODO

% \subsection{Results from running CsPurity on Roslyn's String class} \label{sub:results-from-scanning-roslyn's-string-class}

\subsection{Results from running CsPurity on Microsoft's .NET Reference Source \texttt{String} class} \label{sub:results-string-class}

Reference Source is a publicly available repository by Microsoft that contains sources from the Microsoft .NET Reference Source~\cite{microsoft-referencesource}. Their \texttt{String} class contains 65 methods with the \texttt{[Pure]} attribute out of a total of 178 methods. By scanning methods that are marked with the \texttt{[Pure]} attribute we can determine the accuracy of CsPurity.

However, Microsoft don't seem to count the use of static variables (non-determinism) or calls to methods that throw exceptions as impure. Therefore, the majority of methods with the \texttt{[Pure]} atttribute are in fact impure.

The two classes in Reference Source with the most number of methods with a \texttt{[Pure]} attribute were chosen.

Out of all 65 methods that were marked as \texttt{[Pure]}:

\begin{itemize}
  \item Pure: 2
  \item Impure: 42
  \begin{itemize}
    \item Throws exception: 32
    \item Reads static variable: 10
  \end{itemize}
  \item Unknown: 21
\end{itemize}

% Here, "Throws exception" and "Reads static variable" includes methods that themselves depend on methods that do so.

As seen above, nearly half of all methods with the \texttt{[Pure]} attribute throw exceptions.

Out of all 113 methods that were \textit{not} marked as \texttt{[Pure]}:

\begin{itemize}
  \item Pure: 3
  \item Impure: 58
  \item Unknown: 52
\end{itemize}

Three of the methods with no \texttt{[Pure]} attribute were classified as pure by CsPurity. By looking manually at them it could be confirmed that all three fulfill the properties of functional purity.

% TODO

\section{Related work} \label{sec:Related work} % (If not part of introduction)

\subsection{Purity in Erlang} \label{sub:Purity-in-Erlang}
In their paper \textit{Purity in Erlang} Mihalis Pitidis and Konstantinos Sagonas develop a tool that automatically and statically analyses the purity of Erlang functions~\cite{pitidis2010purity}. It classifies functions into being functionally pure, or one of three levels of functional impurity~\cite{pitidis2010purity}.
The three levels of functional impurity they defined are: containing side-effects; containing no side-effects but being dependent on the environment; and containing no side-effects, having no dependencies on the environment but raising exceptions~\cite{pitidis2010purity}.

Their definition of purity uses \textit{referential transparency}, as it implies purity~\cite{pitidis2010purity}. Referential transparency means that an expression always produces the same value when evaluated~\cite{pitidis2010purity}. This means that a referentially transparent function could always be replaced with it's output without altering the program's behaviour in any way~\cite{pitidis2010purity}.

They store all analysis information in a \textit{lookup table} where the keys are the function identifiers \textit{f} and the values are the purity level \textit{$p_f$} of each \textit{f} as well as \textit{f}'s \textit{dependency set} $D_f$~\cite{pitidis2010purity}. The dependency set is the set of functions being called by \textit{f} and is constructed by parsing the program's Abstract Syntax Tree~\cite{pitidis2010purity}.

Their analysis starts with Erlang's so called built in-functions (BIFs), which are functions native to the Erlang's virtual machine and are written in C~\cite{pitidis2010purity}. Impure actions in Erlang can only be done through BIFs, including performing I/O actions or writing to global variables~\cite{kostis-email}. Because BIFs are written in C they cannot be analysed by their analysis tool, and their purity is assumed to be already known in beforehand by the analysis tool~\cite{pitidis2010purity}. The analysis propagates the impurity of BIFs to each function which directly or indirectly depends on them.

In short terms, their analysis algorithm works like this: Initialize the purity of all functions in the lookup table to be analyzed to "pure"~\cite{pitidis2010purity}. Define the \textit{working set} to always equal the set of functions whose purity level is fully determined, i.e. the functions with empty dependency sets~\cite{pitidis2010purity}. For each function \textit{f} in the working set, propagate its purity level to functions depending on it and "contaminate" them with \textit{f}'s purity level~\cite{pitidis2010purity}. Then remove \textit{f} from the  dependency set of each function depending on it~\cite{pitidis2010purity}. If \textit{f} has the highest impurity level, remove the entire dependency set of each function depending on \textit{f}~\cite{pitidis2010purity}. If the working set gets empty, find a set of functions that are dependent on each other and no other functions, and set their purity level to the purity of the impurest function~\cite{pitidis2010purity}. Simplify their dependency sets by removing their dependency on each other from their dependency set~\cite{pitidis2010purity}. Repeat this process until there are no more changes to the lookup table~\cite{pitidis2010purity}.

The foundation for the analysis method used in this paper is based off the method developed by Pitidis and Sagonas: The approach with using a lookup table to store the intermediate states of the analysis, dependency sets and propagation of impurity from callee to caller using dependency sets. However, the analysis by Pitidis and Sagonas is intended for programs written in Erlang, which is a functional programming language. Also, their analysis gets facilitated by Erlang's BIFs since impure actions can only be performed through them, and so they only need to propagate the impurity of the called BIFs to the callers, and therefore do not need to perform any intermediate analysis on other functions. Since no equivalence to BIFs exists in C\#, our analysis can't only comprise of propagating impurities from callee to caller but also needs to check each function analysed to see if that function performs any impure action.

\subsection{JPure: A Modular Purity System for Java} \label{sub:JPure: A Modular Purity System for Java}
David J. Pearce built a purity system and analyzer for Java in his paper JPure: a modular purity system for Java~\cite{pearce2011jpure}. The system uses the properties \textit{freshness} and \textit{locality} to increase the system's ability to classify methods as pure~\cite{pearce2011jpure}. An object is fresh if it is newly allocated inside a method~\cite{pearce2011jpure}. An object's locality is its local state~\cite{pearce2011jpure}. Pearce's definition of a pure method is one that does not assign (directly or indirectly) to any field that existed before the method was called~\cite{pearce2011jpure}.

The system uses uses the purity annotations \texttt{@Pure}, \texttt{@Local} and \texttt{@Fresh}~\cite{pearce2011jpure}. The annotation \texttt{@Pure} indicates that a method is pure~\cite{pearce2011jpure}. \texttt{@Local} indicates that a method only modifies an object's locality~\cite{pearce2011jpure}. \texttt{@Fresh} indicates that a method only returns fresh objects~\cite{pearce2011jpure}. These three annotations are modularly checkable, i.e. one method's purity annotations to be checked in isolation from all other methods~\cite{pearce2011jpure}.

The system consists of two parts, \textit{purity inference} and \textit{purity checker}~\cite{pearce2011jpure}. Purity inference adds \texttt{@Pure} annotations (and any auxiliary annotations required) to the code and is intended to be run once because it is more costly~\cite{pearce2011jpure}. The purity checker checks the correctness of all annotations at compile-time, and is intended to be used continuously to maintain the code's purity~\cite{pearce2011jpure}.

Pearce's definition of functional purity does not include determinism, unlike the one used in this paper. The purity level \textit{locally impure} used in this thesis is based on Pearce's \texttt{@Local} attribute. Moreover, the solution to method overriding used in this paper in \autoref{sub:inheritance} is also based on the ideas developed by Pearce. However, Pearce's approach requires that the program is modularly checkable, i.e. that each method's purity can be evaluated independently from all other methods, and uses annotations to achieve this~\cite{pearce2011jpure}.  Pearce does not introduce an \textit{unknown} purity level for called methods (referred to as methods from external packages) that are not analyzed, but assumes conservatively that such methods are always impure~\cite{pearce2011jpure}.

% Their analysis seems way more complicated than mine, which could be an advantage

\subsection{Purity and Side Effect Analysis for Java Programs} \label{sub:Purity and Side Effect Analysis for Java Programs}
Similarly to Pearce, Alexandru S\u{a}lcianu and Martin Rinard presented a method for analysing purity in Java programs, but their definition of purity also only includes side-effects and does not look at the input or output, i.e. does not include determinism~\cite{salcianu}. Their pointer analysis is based on tracking object creation and updates, as well as updates to local variables, and defines methods that mutate memory locations that existed before a method call as impure~\cite{salcianu}. Moreover, their analysis can recognize purity-related properties for impure methods, including \textit{read-only} and \textit{safe} parameters~\cite{salcianu}.

The analysis method presented looks at each program point in each method \textit{m}, and computes a points-to graph modelling the parts of the heap that method \textit{m} points to, represented by nodes in the graph~\cite{salcianu}. There are three kinds of nodes: \textit{Inside nodes} which model objects created by \textit{m}, \textit{parameter nodes} which model objects passed to \textit{m} as arguments, and \textit{load nodes} modelling objects read from outside \textit{m}~\cite{salcianu}. Edges in the points-to graph model heap references~\cite{salcianu}. There are two types of edges: \textit{inside edges} which model heap references created by \textit{m}, and \textit{outside edges} modelling heap references read by \textit{m} from outside of it (this includes \textit{m}'s parameters)~\cite{salcianu}.

% For each method \textit{m} the analysis computes a set $W_m$ containing the mutated fields that are externally visible.

The analysis also keeps track of \textit{globally escaped nodes}, which are nodes that may be accessed by unknown code, i.e. passed as argument to a native methods or pointed to static fields~\cite{salcianu}. Since globally escaped nodes may be mutated by unknown code, the analysis has to handle them conservatively~\cite{salcianu}.

To check if a method \textit{m} is pure, the analysis computes the set \textit{A} consisting of nodes reachable from parameter nodes along outside edges~\cite{salcianu}. In other words, \textit{A} represents all objects existing before executing \textit{m}~\cite{salcianu}. \textit{m} is pure if and only if no node in \textit{A} escapes globally (i.e. is accessed by unknown code) and no fields in any node in \textit{A} is modified~\cite{salcianu}. There is one exception to the purity constraint: constructors are allowed to mutate fields of the \texttt{this} object~\cite{salcianu}. Therefore all mutated abstract fields of \texttt{this} are ignored by the analysis~\cite{salcianu}.

Similarly to this thesis, S\u{a}lcianu and Rinard explicitly mark parts of a method that are potentially accessed by unknown code, and deal with them conservatively. Their analysis uses a points-to graph to compute the purity of each method, unlike the method in this thesis that uses a lookup-table and checklist.

% Since they do not include determinism in their definition of functional purity, static

% \subsection{Detecting function purity in JavaScript}
% This was a little too difficult to understand, maybe remove from related work?
% Nicolay et al. developed a method of detecting function purity in JavaScript using something called \textit{pushdown analysis}~\cite{purity-in-javascript}. Their definition of functional purity, however, includes only side-effects and does not require functions' output to depend purely on their input~\cite{purity-in-javascript}.

% Because everything except for

% \subsection{Writing Pure Code in C\#} \label{sub:Writing Pure Code in Cs}
% In his article \textit{Writing Pure Code in C\#} Massad defines three levels of pure methods~\cite{yacoub-massad-pure-code}:
% \begin{enumerate}
%   \item Pure methods, i.e. methods that do not read or write to instance state variables, or call impure methods.
%   \item Methods that are pure, and that \textit{read} the state of their containing object, or the state of objects that are passed as parameters or created in the current method.
%   \item Methods that are pure, and that \textit{read} or \textit{write} to the state of their containing objects, or to the state of objects created in the current method.
% \end{enumerate}

% \subsection{Evolution of Degree of Purity in Programming Languages} \label{sub:Evolution of Degree of Purity in Programming Languages}
% Rajasekhara Babu et al.~\cite{rajasekharababu2012evolution}.

\subsection{Verifiable Functional Purity in Java} \label{sub:Verifiable-Functional-Purity-in-Java}
In their definition of functional purity Finifter et al. require pure functions to be both side-effect free and \textit{deterministic}~\cite{purity-in-java}. A function is deterministic if any two evaluations of it have the same result~\cite{purity-in-java}. This means that a deterministic function is one that relies purely on its arguments~\cite{purity-in-java}. A function is side-effect free if it only modifies objects that were created during its execution~\cite{purity-in-java}.

The language that their analyzer handles is a subset of Java, in which they can prove functional purity~\cite{purity-in-java}. If a method is written in this subset of Java and its parameters are immutable, including the implicit \texttt{this}, then the method is pure~\cite{purity-in-java}. % page 166
If its class is immutable it means that a method's global scope has a constant state, and so the only varying state is the one observable through its arguments~\cite{purity-in-java}.

Their verifier has a whitelist of fields and methods from Java libraries that do not expose the ability to observe a global mutable state, or provide access to nondeterminism, and it will reject any reference to a field or method that is not on the list~\cite{purity-in-java}. This is similar to the approach with a list of impure built-in C\# methods used in this thesis and mentioned in \autoref{sub:Impure-built-in-methods}.

Finifter et al. use the same definition of functional purity that is used in this thesis. The main disadvantage with Finifter et al.'s approach is that it requires the code to be written in a subset of Java code in order to be able to analyze the code.

\subsection{Dynamic Purity Analysis For Java Programs} \label{sub:Dynamic Purity Analysis For Java Programs}
In their paper Xu et al. define four different definitions for functional purity, and they are as follows from the strongest to the weakest definition: \textit{strong}, \textit{moderate}, \textit{weak} and \textit{once-impure} purity~\cite{xu2007dynamic}, similarly to the purity levels presented in this thesis in \autoref{def:functional-purity}, \autoref{def:locally-impure} and \autoref{def:parametrically-impure}. Their strongest definition, \textit{strong purity}, includes both determinism and side-effect freeness~\cite{xu2007dynamic}. However, Xu et al. do not seem to consider object type parameters to be included in determinism, and so reading the state of an input object is not considered truly pure. \textit{Moderate purity} is like \textit{strong}, except that it also allows modification of newly allocated (i.e. fresh) objects~\cite{xu2007dynamic}. \textit{Weak purity} is like \textit{moderate}, but it also allows non-determinism i.e. reading from objects that exist outside of the method~\cite{xu2007dynamic}. \textit{Once-impure purity} is equivalent to \textit{weak purity} except that the first invocation of the method may be impure~\cite{xu2007dynamic}.

It is interesting that Xu et al. do not consider modification of fresh objects or reading the state of object type input parameters as truly pure, which this paper and most other work does. Moreover, none of Xu et al.'s purity levels however allow modification of input parameters. Xu et al. consider methods that modify their own object \texttt{this} to be impure, but do allow other methods that call such methods and remain \textit{moderately pure}. This is similar to the approach used in this paper, which classifies the former type of method as \textit{locally impure} and the calling method as \textit{pure} if the called method belongs to a fresh object, as described in \autoref{sub:modifying-fresh-objects}.

Xu et al.'s analysis is performed dynamically which requires looking at Java Virtual Machine code~\cite{xu2007dynamic}. The nature of the dynamic analysis may be the reason why some of their purity definitions differ from most other work, for instance that any modification of any object that was created after the start of executing a method, including fresh ones, is not considered pure by their method of analysis.

\section{Conclusion and Future Work} \label{sec:Conclusion and future Work} % Maybe only "Conclusion"

\subsection{Conclusion} \label{sub:Conclusion}

Functional purity is perhaps the most useful concept from functional programming that object oriented programmers can learn from. The definition of a pure program used in this paper is one that is side-effect free and deterministic. There are many benefits of using functionally pure methods in object oriented programming. Pure methods are generally easier to reason about due to their lack of side effects. Moreover, pure methods are easier to test, debug and maintain. The ability to automatically determine the level of purity in a given C\# program can help programmers to write less impure code, and thereby reap previously mentioned benefits.

\subsection{Future work} \label{sub:Future work}

\begin{itemize}
  \item Tool can point out exact position of impurity and suggest improvements to increase the purity. Because purity is determined by passing the purity level of impure functions to their callers, this could be implemented by also passing the identifier of the impure function to the caller.
\end{itemize}

\bibliography{references}

%\appendix % markerar att resten är appendix

\end{document}
